<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>asynchronous on Aryido Tech Note</title><link>https://aryido.github.io/tags/asynchronous/</link><description>Recent content in asynchronous on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Mar 2025 19:46:08 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/asynchronous/index.xml" rel="self" type="application/rss+xml"/><item><title>Python : Coroutine 和 await/async</title><link>https://aryido.github.io/posts/python/async-await/</link><pubDate>Sat, 15 Mar 2025 19:46:08 +0800</pubDate><guid>https://aryido.github.io/posts/python/async-await/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前有介紹了 &lt;a href="https://aryido.github.io/posts/develop/concurrency-asynchronous/">Asynchronous&lt;/a> ，而 Python 的 &lt;strong>Coroutine 是實現 Asynchronous 的一種設計方式&lt;/strong>，且 Python 目前已經有非常直觀簡單的語法糖來定義 Asynchronous Code，使得程式寫起來就像普通的 「 Sequential Processing 順序執行 」任務那樣，但同時卻也可以對&lt;strong>目標函數標註做「等待」的動作，並在「等待」期間可以先去做其他任務&lt;/strong>，達成非同步的功效，提高程式的並發性，而其重要的關鍵字就是 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>await&lt;/code> : 用來標記 Coroutine 切換暫停和繼續的位置&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;code>async&lt;/code> : 用來宣告 function 能夠有異步的功能成為 Coroutine function&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>而這兩個關鍵字是在 &lt;code>Python3.5&lt;/code> 引入且在 &lt;code>Python3.7&lt;/code> 成為&lt;strong>保留關鍵字&lt;/strong>。它們在著名的 FastAPI 框架下的 path operation function 也經常使用，接下來就簡單介紹一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Concurrency 與 Asynchronous</title><link>https://aryido.github.io/posts/develop/concurrency-asynchronous/</link><pubDate>Fri, 14 Mar 2025 12:25:54 +0800</pubDate><guid>https://aryido.github.io/posts/develop/concurrency-asynchronous/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面基本介紹了 &lt;a href="https://aryido.github.io/posts/develop/process-thread/">Process 、 Thread&lt;/a>，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「&lt;strong>多執行緒(Multithreading)&lt;/strong>」和「&lt;strong>多進程(Multiprocessing)&lt;/strong>」來協調達成的，再來是要如何&lt;strong>更高效更多工&lt;/strong>的處理多個不同的工作，變成是經常需要思考的問題，這時 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非同步（Asynchronous）&lt;/strong> : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分&lt;/li>
&lt;li>&lt;strong>併發（Concurrency）&lt;/strong> : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生&lt;/li>
&lt;/ul>
&lt;p>兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Process、Thread</title><link>https://aryido.github.io/posts/develop/process-thread/</link><pubDate>Thu, 13 Mar 2025 19:27:31 +0800</pubDate><guid>https://aryido.github.io/posts/develop/process-thread/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>電腦運行時&lt;strong>任務的的單元是什麼呢&lt;/strong>？ 這個涉及了「程式(Program)」、「進程(Process)」、「線程(Thread)」的概念，是面試時經常會被問到的題目，首先&lt;strong>默念默背&lt;/strong>一下教科書上 Process 和 Thread 的簡單定義：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Process： 資源分配的最小單位&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Thread： CPU 執行的最小單位&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在實際生活中如點開一個聊天應用程式，這就是將 Program 活化成 Process 的例子，因此我們可以在電腦的資源管理器 Monitor 中看到 PID (Process ID) ; 再繼續以聊天室 Process 為例，我們可以同時「接受對方傳來的訊息」以及「發送自己的訊息給對方」，這就是同個 Process 中不同 Thread 的功勞。&lt;/p>
&lt;/blockquote></description></item></channel></rss>