<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Aryido Tech Note</title><link>https://aryido.github.io/tags/docker/</link><description>Recent content in docker on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 30 May 2024 18:52:24 +0800</lastBuildDate><atom:link href="https://aryido.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>GCP - Virtual Private Cloud 概述</title><link>https://aryido.github.io/posts/google-cloud/vpc/</link><pubDate>Thu, 30 May 2024 18:52:24 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/vpc/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Virtual Private Cloud 虛擬私有雲網路，簡寫為 VPC、網路、VPC Network、Network 等等都可以，是 Google 使用 &lt;a href="https://01.me/2014/03/networking-at-google/">Andromeda&lt;/a>(/ænˈdrɑː.mə.də/) 網路虛擬化技術實現的一個雲端資源，提供如 GCP-VM、GKE、Serverless Workloads 或 App Engine 等等雲端服務的「網路功能」，能讓 User 高自由度的建立管理和優化網路架構。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon VPC&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Virtual Network&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>GCP-VPC 和 AWS-VPC 架構上蠻不一樣的，GCP-VPC 是全球性的，只要在同一個 GCP-VPC 內，就算不同 Region 也能使用 Internal IP ; 但如果是不同的 GCP-VPC 就算在同一個 Region 下也不能互相通訊。而 AWS-VPC 是針對 Region 來設計的，故 AWS-VPC 只要跨 Region 就不是內網無法直接溝通，需再多做其他設定才能連線到彼此。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes: command &amp; arguments</title><link>https://aryido.github.io/posts/kubernetes/command-arguments/</link><pubDate>Sun, 07 May 2023 20:22:59 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/command-arguments/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>當我們在編寫 Kubernetes Pod 相關的 yaml spec 時，有時會針對 spec.containers ，設置啟動時要執行的命令及其參數，而 Kubernetes 提供 &lt;code>command &lt;/code> 和 &lt;code>args&lt;/code>，兩種方式可以選擇。但這時候就會出現一些疑問 :&lt;/p>
&lt;ul>
&lt;li>這兩個差異是甚麼 ?&lt;/li>
&lt;li>Docker Image 中如果自帶 ENTRYPOINT 和 CMD ，若 Kubernetes 再設置 &lt;code>command&lt;/code> 和 &lt;code>args&lt;/code> 會發生甚麼事情呢 ?&lt;/li>
&lt;/ul>
&lt;p>以下就來簡單說明一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Dockerfile - RUN、CMD、ENTRYPOINT 範例及比較</title><link>https://aryido.github.io/posts/docker/run-cmd-entrypoint-example/</link><pubDate>Sun, 09 Apr 2023 14:44:54 +0800</pubDate><guid>https://aryido.github.io/posts/docker/run-cmd-entrypoint-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>RUN、CMD 和 ENTRYPOINT 指令都可以用來執行具體的命令。RUN 指令是在 Docker &lt;strong>鏡像構建&lt;/strong>時把執行結果會記錄到鏡像中；而 CMD 和 ENTYPOINT 指令是在&lt;strong>容器啟動&lt;/strong>時自動執行。&lt;/p>
&lt;p>ENTRYPOINT 和 CMD 的區別在於使用 ENTRYPOINT 時， CMD 指令會被作為其&lt;strong>默認參數&lt;/strong>，也可以在啟動容器時通過覆蓋 CMD 指令來輸入參數。&lt;/p>
&lt;/blockquote></description></item><item><title>Dockerfile - RUN、CMD、ENTRYPOINT 介紹</title><link>https://aryido.github.io/posts/docker/run-cmd-entrypoint/</link><pubDate>Sat, 08 Apr 2023 12:50:16 +0800</pubDate><guid>https://aryido.github.io/posts/docker/run-cmd-entrypoint/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dockerfile 讓我們可以透過設定&lt;strong>指令&lt;/strong>的方式，快速地更新和建構 Image 。由於 Dockerfile 中可以清楚的知道 Image 建構的過程和引用的 package 組成，因此在安全性上會有所提升；也因為是純文字檔，所以 size 很小、易於分享。Dockerfile 裡面有一些指令蠻容易混淆的，這次重點介紹:&lt;/p>
&lt;ul>
&lt;li>RUN&lt;/li>
&lt;li>CMD&lt;/li>
&lt;li>ENTRYPOINT&lt;/li>
&lt;/ul>
&lt;p>這三個指令都可以用來執行具體的命令，&lt;strong>但其中又有些差異&lt;/strong>，以下做一些說明和整理。&lt;/p>
&lt;/blockquote></description></item></channel></rss>