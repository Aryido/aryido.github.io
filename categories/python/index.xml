<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Aryido Tech Note</title><link>https://aryido.github.io/categories/python/</link><description>Recent content in python on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 04 Oct 2025 21:52:30 +0800</lastBuildDate><atom:link href="https://aryido.github.io/categories/python/index.xml" rel="self" type="application/rss+xml"/><item><title>uv - Python package and project manager</title><link>https://aryido.github.io/posts/python/uv/</link><pubDate>Sat, 04 Oct 2025 21:52:30 +0800</pubDate><guid>https://aryido.github.io/posts/python/uv/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>uv 是 Astral 公司推出的一款基於 Rust 編寫的「 &lt;strong>Python 套件管理工具&lt;/strong> 」，雖然 Python 的套件管理生態內已經存在多種工具如 pip 、 poetry 、 conda 等等，但在效能、相容性和功能上 uv 都有出色表現，得益於使用 Rust 進行編寫，uv 工具的速度讓人驚艷 ；且從「 安裝管理 Python 版本 」、「 虛擬環境建置」、「 package 依賴 」以上 uv 全部都統整好了，其目標是取代多種現有工具，為 Python 專案的開發和管理帶來了新的選擇。 uv 也成為 Astral 公司繼 Ruff (Python 程式碼檢查器和格式化工具) 之後，另一個知名的專案了。&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Iterable, Iterator, Generator 綜合介紹</title><link>https://aryido.github.io/posts/python/iterable-iterator-generator/</link><pubDate>Sun, 31 Aug 2025 15:59:56 +0800</pubDate><guid>https://aryido.github.io/posts/python/iterable-iterator-generator/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前段時間發現自己對 Python 的 Iterable、Iterator、Generator 之間的差別並沒有很熟稔，我們都知道這三個都可以使用 for loop 來遍歷，再進一步思考一下所謂的 for-loop 是怎麼實現的。 首先已常見的 list 來說，它本身是一個有 index 的結構，可以一個一個拿出來，蠻符合 for-loop 的使用直覺 ; 但是 dict 也是可以用 for loop 走訪呀，而它並不是順序排列的 ; 甚至 open 的 file 都可以用 for loop 結構來讀取每個 row ，那這些為什麼也能用 for-loop 呢？ 這背後有兩個核心概念： &lt;strong>Iterable(可迭代對象)&lt;/strong> 和 &lt;strong>Iterator(迭代器)&lt;/strong> 。&lt;/p>
&lt;p>當我們了解 Iterable 和 Iterator 之後，就可以進一步來了解 Generator ，同時再來把這三個做一個比較整理。&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Type Hint</title><link>https://aryido.github.io/posts/python/type-hint/</link><pubDate>Sat, 26 Apr 2025 14:39:56 +0800</pubDate><guid>https://aryido.github.io/posts/python/type-hint/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們都知道 Python 是一個動態的語言，代表每一個 variable 是什麼型別是在 runtime 的時候決定的，雖然很靈活可是當 code 量級上去之後因爲類型不正確引發的錯誤也會逐漸增加。但 Python 也是可以做到型別要求的，就是使用 「 Type Hint 」 或者叫 「 Type Annotation 」，中文稱呼蠻多種的例如「型別標註」、「型別提示」等等。 若有寫 Type Hint 的話，比較現代的 IDE 都會有一些自動顯示或補全輔助 :
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/python/ide-hint.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/python/ide-hint.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;p>Python 的 Type Hint 是從&lt;code>3.5&lt;/code>開始萌芽逐漸引入直到現在，故有一些發展的歷史脈絡和演變，有一些寫法也漸漸更替，故簡單介紹和分析一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Coroutine 的核心 - Event-Loop</title><link>https://aryido.github.io/posts/python/event-loop/</link><pubDate>Sun, 16 Mar 2025 22:56:39 +0800</pubDate><guid>https://aryido.github.io/posts/python/event-loop/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Python 的 Coroutine 發展已經逐漸穩定成熟，已經成為了提升 Python 程式效能的優秀解決方案之一，在之前簡單介紹 &lt;a href="https://aryido.github.io/posts/python/async-await/">Coroutine 和 await/async&lt;/a> 時，我們在範例 code 中一直有用到一個 Python buildin 模組 &lt;code>asyncio&lt;/code>，它提供了一套完整的工具和接口，用於建立非同步應用程式，其核心是 Event-Loop，會追蹤所有註冊的任務，並根據任務的狀態調度它們的執行。 故接著來了解 Event-Loop 和其工作的執行單位 Task 吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Coroutine 和 async/await</title><link>https://aryido.github.io/posts/python/async-await/</link><pubDate>Sat, 15 Mar 2025 19:46:08 +0800</pubDate><guid>https://aryido.github.io/posts/python/async-await/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前有介紹了 &lt;a href="https://aryido.github.io/posts/develop/concurrency-asynchronous/">Asynchronous&lt;/a> ，而 Python 的 &lt;strong>Coroutine 是實現 Asynchronous 的一種設計方式&lt;/strong>，且 Python 目前已經有非常直觀簡單的語法糖來定義 Asynchronous Code，使得程式寫起來就像普通的 「 Sequential Processing 順序執行 」任務那樣，但同時卻也可以對&lt;strong>目標函數標註做「等待」的動作，並在「等待」期間可以先去做其他任務&lt;/strong>，達成非同步的功效，提高程式的並發性，而其重要的關鍵字就是 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>async&lt;/code> : 用來宣告 function 能夠有異步的功能成為 Coroutine function&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;code>await&lt;/code> : 用來標記 Coroutine 切換暫停和繼續的位置&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>而這兩個關鍵字是在 &lt;code>Python3.5&lt;/code> 引入且在 &lt;code>Python3.7&lt;/code> 成為&lt;strong>保留關鍵字&lt;/strong>。它們在著名的 FastAPI 框架下的 path operation function 下也經常使用，接下來就簡單介紹一下吧。&lt;/p>
&lt;/blockquote></description></item></channel></rss>