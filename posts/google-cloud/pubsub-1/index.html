<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GCP - Pub/Sub 概述 I - 架構","image":"https://aryido.github.io/images/google-cloud/pubsub/pubsub-logo.jpg","datePublished":"2024-08-17T23:18:06+08:00","dateModified":"2024-08-17T23:18:06+08:00","author":{"@type":"Person","name":"李昀陽 YunYang Lee","image":"https://aryido.github.io/images/aboutme/head-shot.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/aryido.github.io\/posts\/google-cloud\/pubsub-1\/"},"publisher":{"@type":"Organization","name":"Aryido Tech Note","logo":{"@type":"ImageObject","url":"https://aryido.github.io/images/aboutme/head-shot.jpg"}},"description":" Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :\nAmazon Web Services (AWS) : SQS + SNS Microsoft Azure : Azure Service Bus Messaging Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 Pub/Sub service level agreement (SLA)，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.119.0 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="李昀陽 YunYang Lee"><meta name=keywords content><meta name=description content="

Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :

Amazon Web Services (AWS) : SQS + SNS
Microsoft Azure : Azure Service Bus Messaging

Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 Pub/Sub service level agreement (SLA)，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。
"><meta property="og:description" content="

Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :

Amazon Web Services (AWS) : SQS + SNS
Microsoft Azure : Azure Service Bus Messaging

Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 Pub/Sub service level agreement (SLA)，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。
"><meta property="og:type" content="article"><meta property="og:title" content="GCP - Pub/Sub 概述 I - 架構"><meta name=twitter:title content="GCP - Pub/Sub 概述 I - 架構"><meta property="og:url" content="https://aryido.github.io/posts/google-cloud/pubsub-1/"><meta property="twitter:url" content="https://aryido.github.io/posts/google-cloud/pubsub-1/"><meta property="og:site_name" content="Aryido Tech Note"><meta property="og:description" content="

Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :

Amazon Web Services (AWS) : SQS + SNS
Microsoft Azure : Azure Service Bus Messaging

Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 Pub/Sub service level agreement (SLA)，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。
"><meta name=twitter:description content="

Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :

Amazon Web Services (AWS) : SQS + SNS
Microsoft Azure : Azure Service Bus Messaging

Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 Pub/Sub service level agreement (SLA)，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。
"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2024-08-17T23:18:06"><meta property="article:modified_time" content="2024-08-17T23:18:06"><meta property="article:section" content="cloud"><meta property="article:section" content="gcp"><meta property="article:tag" content="data-exchange"><meta name=twitter:card content="summary"><meta property="og:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="og:image" content="https://aryido.github.io/images/google-cloud/pubsub/pubsub-logo.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/google-cloud/pubsub/pubsub-logo.jpg"><title>GCP - Pub/Sub 概述 I - 架構</title><link rel=icon href=https://aryido.github.io/favicon.png><link rel=canonical href=https://aryido.github.io/posts/google-cloud/pubsub-1/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://aryido.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://aryido.github.io/ aria-label="Go to homepage">Aryido Tech Note</a></div><a class=header-right-picture href=https://aryido.github.io/#about aria-label="Open the link: /#about"><img class=header-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://aryido.github.io/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>李昀陽 YunYang Lee</h4><h5 class=sidebar-profile-bio>Welcome to my Tech Note. You can read some of the chapters below.</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/Aryido target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/index.xml title=RSS><i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden=true></i>
<span class=sidebar-button-desc>RSS</span></a></li></ul><ul class=sidebar-buttons></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>GCP - Pub/Sub 概述 I - 架構</h1><div class="postShorten-meta post-meta"><time datetime=2024-08-17T23:18:06+08:00>August 17, 2024</time>
<span>in</span>
<a class=category-link href=https://aryido.github.io/categories/cloud>cloud</a>,
<a class=category-link href=https://aryido.github.io/categories/gcp>gcp</a></div></div><div class="post-content markdown"><div class=main-content-wrap><blockquote><p>Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :</p><ul><li>Amazon Web Services (AWS) : <strong>SQS + SNS</strong></li><li>Microsoft Azure : <strong>Azure Service Bus Messaging</strong></li></ul><p>Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 <a href="https://cloud.google.com/pubsub/sla?hl=en">Pub/Sub service level agreement (SLA)</a>，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。</p></blockquote><hr><h1 id=pubsub-components>Pub/Sub Components</h1><p>Pub/Sub 需瞭解 Publisher、Topic、Subscription、Subscriber 等幾個關鍵名詞就可以開始設計 Message Service，其運作流程和關係簡單用下圖來進行介紹：</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/pubsub-components.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/pubsub-components.jpg></a></div><p>例如有兩個不同的 Applications 會個別產生 Message 資料的主體，在這裏 Applications 個別稱為</p><ul><li><code>Publisher 1</code></li><li><code>Publisher 2</code></li></ul><p>而 Publisher 也可稱為 「Producer 產生者」，會把 Message 它發送至指定 Topic。上圖中 Publishers 個別產生的 <code>Message A</code>、<code>Message B</code> 是決定送到同一個指定的 Topic，也代表是兩個 Message 是同一種類型且格式都一樣。</p><p>再來可能由於想分給<strong>兩個不同系統</strong>去處理同一個 Message，故讓 Topic 附加到</p><ul><li><code>Subscription 1</code></li><li><code>Subscription 2</code></li></ul><p>這樣架構下不論是訂閱 <code>Subscription 1</code> 還是 <code>Subscription 2</code> 其中的哪一個，都可以收到 <code>Message A</code>、<code>Message B</code>，這就是所謂的 <strong>Fan-out</strong> 架構。</p><p>最後上圖中發現 <code>Subscription 1</code> 有連接到兩個 Subscriber 分別是</p><ul><li><code>Subscriber 1</code></li><li><code>Subscriber 2</code></li></ul><p>這兩個 Subscriber 會並行一起幫忙處理 Message 增快處理速度，像圖中表示是 <code>Subscriber 1</code> 處理 <code>Message B</code> 而 <code>Subscriber 2</code> 處理 <code>Message A</code>，其中一個正常處理完 Message 之後，其他的 Subscriber 就不會處理該消息了。</p><p>比較簡單的是 <code>Subscription 2</code>，僅連接到單個訂閱者 <code>Subscriber 3</code> 來處理資料。</p><h1 id=pubsub-resources-naming-guideline>Pub/Sub Resources Naming Guideline</h1><p>Pub/Sub 的許多資源如 Topic、Subscription、Schema 等名稱會符合以下格式：</p><blockquote><p><code>projects/{PROJECT-ID}/{COLLECTION}/{ID}</code></p></blockquote><p>其中 <code>COLLECTION</code> 會是 <code>topics</code> 、<code>subscriptions</code>、<code>schemas</code>、<code>snapshots</code> 其中一個，然後最後的 <code>ID</code> 也有命名限制如下 :</p><ul><li>不能以 <code>goog</code> 為開頭</li><li>必須以字母開頭</li><li>長度限制 <code>3 ~ 255</code> 個 characters</li><li>只能包含：<code>[A-Za-z][0-9]-_.~+%</code></li></ul><h3 id=topic--schema>Topic & Schema</h3><p>Publisher 會發送 Message 至 Topic 這個目的地，然後加上要創建 Subscription 必須訂閱某個指定 Topic 才行，故要使用 Pub/Sub 的<strong>首先任務是需先創建 Topic</strong> 。另外 Topic 可以設定 Schema ，用於強制 Pub/Sub Message 中資料欄位的格式，有 <strong>Apache Avro</strong> 和 <strong>Protobuf</strong> 可以選擇， <strong>是 Optional 功能</strong>。</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/topic.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/topic.jpg></a></div><p>Pub/Sub 有兩種類型的 Topic :</p><ul><li><code>standard topic</code></li><li><code>import topic</code></li></ul><p><code>import topic</code> 比較特別，它可以讓外部資料源(External DataSource)，把<strong>外部資料 Ingest 到 GCP 的 Topic</strong>，也就是上圖中的 <code>Enable ingestion</code> 的功能。例如說現在可以把 AWS Kinesis 的 streaming data 導入 GCP 的 Topic 。</p><div class="alert success"><p><p>官網上建議 <code>import topic</code> 使用在 streaming data 上。如果是考慮是 <strong>Batch 批量</strong> ingest 資料而不是 streaming data ingestion，則 :</p><ul><li>到 BigQuery 中可考慮使用 <strong>BigQuery Data Transfer Service (BQ DTS)</strong></li><li>到 Cloud Storage 中考慮使用 <strong>Storage Transfer Service (STS)</strong></li></ul></p></div><h3 id=subscription--subscriber>Subscription & Subscriber</h3><p>Subscription 會連接指定的 Topic ; 而 Subscriber 也稱為 「Consumer 消費者」會連接 Subscription 並處理 Message。 創建 Subscription 時要選擇 delivery Message 的方式：</p><blockquote><ul><li><strong>Pull subscription</strong>: Subscriber 會去請求 Pub/Sub 來拉取資料</li><li><strong>Push subscription</strong>: Pub/Sub server 會推送資料至目標 EndPoint</li><li><strong>Export subscription</strong>: 可直接把 Pub/Sub 的資料寫到 BigQuery 或 Cloud Storage</li></ul></blockquote><p>默認 Subscription 對於 Message 處理的設定，是 <strong>at-least-once delivery with no ordering guarantees</strong>，保證至少會傳送一次且沒有排序。若以上並不滿足有其他進階需求，Pub/Sub 也有提供 <a href=https://cloud.google.com/pubsub/docs/exactly-once-delivery>exactly-once delivery</a> 和 <a href=https://cloud.google.com/pubsub/docs/ordering>message ordering</a> 可以設定，屬進階內容暫且略過。</p><div class="alert warning"><p>目前簡單看起來要讓消息排序，只支持在<strong>同一 region 下</strong>有序</p></div><p>Pub/Sub Subscription 對於「<strong>過期時間</strong>」有蠻多不同的地方都可以設定，為避免混淆以下稍微解釋一下 :</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/expire-setting.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/expire-setting.jpg></a></div><ul><li><h5 id=expiration-period><strong>Expiration period</strong></h5><p>這個設定是針對 subscription 的設定: 若 subscription 沒有和任何 subscriber 產生 Pull/Push 甚至沒有連線達到一段時間，就會 inactive subscription，可以設定的區間目前是 <code>7 ~ 365 days</code>。當然也可以永遠 never expire</p></li><li><h5 id=message-retention-duration><strong>Message retention duration</strong></h5><p>消息中間件有一個大功用就是保存 Message 達到「消減流量高峰」的目的，可以設定的區間目前是 <code>10 mins ~ 7 days</code>。 通常 Message 在 Acked 之後都會從 Message storage 中刪除，這邊也可以進一步設定連 acknowledged messages 都保存 retained</p></li><li><h5 id=acknowledgement-deadline><strong>Acknowledgement deadline</strong></h5><p>是在實作面上最需要注意的設定，可以設定的區間目前是 <code>10 ~ 600 seconds</code>。 因為有些 Message 處理時間可能會偏長，若設定 Acknowledgement deadline 太短會造成很多 Message 都是 Unacked 狀態導致重複投遞甚至重複消費</p></li></ul><h1 id=pubsub-pattern>Pub/Sub Pattern</h1><p>Pub/Sub 的架構模式蠻多樣化的，也因如此 Message Service 在 GCP 產品上比較單一，比起其他雲端的多種不同 Message Service 服務，個人覺得 GCP 在這方面比較統一方便</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/pubsub-patterns.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/pubsub-patterns.jpg></a></div><p>架構上特別注意 <strong>Fan in (many-to-one)</strong> 和 <strong>Fan out (one-to-many)</strong>，這裡指的是 <strong>「Publisher」對上「Subscription」</strong>。</p><blockquote><ul><li>如果需要對 Message 執行不同的 pipe line 操作處理時， <strong>Fan out</strong> 就是必需的架構</li></ul></blockquote><blockquote><ul><li>而對於 <strong>(many-to-many)</strong> 的形容比較是在 Load balanced 方面，是使用多個 Subscriber 大規模處理對應 Subscription 內收到的消息。</li></ul></blockquote><hr><h1 id=pubsub-comparison>Pub/Sub Comparison</h1><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/real-usecases.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/real-usecases.jpg></a></div><p>Pub/Sub 消息傳遞服務在使用場景上非常多元，故會有很多類似的產品可以做比較，無論是對應到 GCP 平台的其他服務還是對比其他雲平台 AWS 、 Azure 的其他服務。</p><h3 id=pubsub-和其他-gcp-類似產品的比較>Pub/Sub 和其他 GCP 類似產品的比較</h3><ul><li><h5 id=cloud-tasks>Cloud Tasks</h5><p>Cloud Tasks 和 Pub/Sub 都可用於 Asynchronous Message-Passing，概念上相似，但主要差別是在 「Implicit invocation」 和 「Explicit invocation」 :</p><blockquote><ul><li><strong>Pub/Sub</strong> 屬於 Implicit invocation 隱式調用，因為 Pub/Sub 主要目的是把 Publisher 和 Subscriber 解耦，故 Publisher 是不會知道 Subscriber 的任何資訊的</li></ul></blockquote><blockquote><ul><li><strong>Cloud Tasks</strong> 屬於 Explicit invocation 顯式調用，這時 Publisher 是直接指定 Endpoint 來傳送消息，故 Cloud Tasks 適用的場景有: 定時任務觸發特 webhook、遠端 procedure 調用</li></ul></blockquote></li><li><h5 id=firebase>Firebase</h5><p>根據官網所敘述，Pub/Sub 主要是用於 Service-To-Service 的訊息異步傳遞，而不是用於 End-User 或 IoT Clients 的通訊，所以若主要是讓 Mobile 或 Web-App 和 Service 溝通的話，<strong>尤其是 Mobile 可以考慮 Firebase 系列展品</strong></p></li><li><h5 id=pubsub-lite>Pub/Sub Lite</h5><div class="alert danger"><p>目前是 <strong>deprecated 產品</strong>，故不要再使用它了，<code>2026/3/18</code> 會被關閉，建議將 Pub/Sub Lite 服務遷移到 Apache Kafka 或 Pub/Sub 。</p></div></li></ul><h3 id=pubsub-和其他雲端類似產品的比較>Pub/Sub 和其他雲端類似產品的比較</h3><p>讓獨立 App 應用之間進行 Asynchronous Requests 傳遞訊息主的話，對應到 AWS 和 Azure 的雲端服務分別是 :</p><blockquote><ul><li>Simple Notification Service (<strong>SNS</strong>)</li><li>Simple Queue Service (<strong>SQS</strong>)</li><li>Amazon MQ</li></ul></blockquote><blockquote><ul><li>Azure Service Bus Messaging</li><li>Azure Storage Queues</li></ul></blockquote><p>Pub/Sub 是一個強大服務，既支持<strong>訂閱推送</strong>模型也可以像<strong>消息隊列</strong>一樣使用。相比之下 AWS 提供兩個不同的消息傳遞服務設計: SNS 和 SQS ，其區別簡述如下：</p><ul><li><h5 id=sns-分散式主題訂閱>SNS (分散式主題/訂閱)</h5><p>當生產者把消息發送給 SNS 服務後，會<strong>將消息推送給多個訂閱者</strong>如 : Short Message Service ( SMS 簡訊服務) 、 電子郵件服務 、 Simple Queue Service (SQS) 或 AWS Lambda 。因為一條消息會同時傳遞給多個訂閱者，故適合廣播通知，屬於 <strong>Fan out 設計</strong></p></li><li><h5 id=sqs-分散式消息隊列>SQS (分散式消息隊列)</h5><p>SQS 是消息隊列，消息由一個生產者放入隊列中，不會主動發送給用戶端，由一個或多個消費者按 FIFO 順序拉取消息進行處理，適合任務隊列，供點對點的消息傳遞</p><p>由於在 AWS SQS 中，並沒有支援 <strong>fan-out</strong> 的功能，想要實作類似的架構需要透過 SNS + SQS 整合才行，所以個人認為 Pub/Sub 比較接近 <code>SNS + SQS</code>：</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/aws-fan-out-sqs.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/aws-fan-out-sqs.jpg></a></div></li><li><h5 id=amazon-mq>Amazon MQ</h5><p>另外 AWS 也提供托管的 Message Service 稱為 <strong>Amazon MQ</strong>，支援開源產品如 Apache ActiveMQ 和 RabbitMQ，適合那些使用已經使用標準消息傳遞協議（如 JMS、AMQP、MQTT 等）的應用，可將現有本地 Infra 從地端遷移到雲端來管理</p></li><li><h5 id=azure-service-bus-messaging>Azure Service Bus Messaging</h5><p>是 Azure 提供的一個企業級 Message Service ，支持先入先出（FIFO）消息順序、消息排隊、發布/訂閱模式、延遲消息以及事務性消息處理</p></li><li><h5 id=azure-storage-queues>Azure Storage Queues</h5><p>算是 Azure Storage 的一部分功能，設計用於簡單的消息隊列，支持將大量小消息以非同步的方式存儲和傳遞，適合輕量級的應用間通信和後台任務處理。對比起來和 GCP 的 Cloud task 比較接近</p></li></ul><p>以大數據 Streaming Data Ingest 為主的話， Pub/Sub 對應到其他的雲端服務是 :</p><blockquote><ul><li>Amazon Web Services (AWS) : <strong>Amazon Kinesis</strong></li><li>Microsoft Azure : <strong>Azure Event Hubs</strong></li></ul></blockquote><p>以上這些都是設計用來處理高吞吐量的 Streaming Data，偏向屬於專門 Data-Engineer 或 Data-Science 領域的雲端工具，下圖就舉例一個 GCP Big-Data Analysis 的一種經典架構 :</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/google-cloud/pubsub/example.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/google-cloud/pubsub/example.jpg></a></div><div class="alert success"><p>相似的產品非常多，若真的想了解其中差異可能還會需要更多的實際使用才能比較，以上就先列出來</p></div><hr><h3 id=參考資料>參考資料</h3><ul><li><p><a href=https://cloud.google.com/pubsub/docs/overview>What is Pub/Sub?</a></p></li><li><p><a href="https://www.youtube.com/watch?v=hQE14DX4LHQ&amp;t=134s">[GCP 教學] 043 2 小時學完 GCP 重點服務 VM, LB, Kubernetes, DevOps, 混合雲, 資料庫, 大數據, 機器學習, AI, 網路防禦, 權限, 資訊安全等</a></p></li><li><p><a href=https://juejin.cn/post/7039341353678929933>SQS 和 SNS 對比分析</a></p></li><li><p><a href=https://ikala.cloud/google-cloud-pub-sub-aws-sqs-comparison/>拆解雲端 Message Service：Google Cloud Pub/Sub vs. AWS SQS 優劣分析</a></p></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://aryido.github.io/tags/data-exchange/>data-exchange</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/google-cloud/iam/ data-tooltip="GCP - Identity and Access Management 概述" aria-label="NEXT: GCP - Identity and Access Management 概述"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/google-cloud/storage-service-all/ data-tooltip="GCP 儲存服務 - 總整理" aria-label="PREVIOUS: GCP 儲存服務 - 總整理"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 李昀陽 YunYang Lee. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/google-cloud/iam/ data-tooltip="GCP - Identity and Access Management 概述" aria-label="NEXT: GCP - Identity and Access Management 概述"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/google-cloud/storage-service-all/ data-tooltip="GCP 儲存服務 - 總整理" aria-label="PREVIOUS: GCP 儲存服務 - 總整理"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"><h4 id=about-card-name>李昀陽 YunYang Lee</h4><div id=about-card-bio>Welcome to my Tech Note. You can read some of the chapters below.</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Software Engineer</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Taiwan</div></div></div><div id=cover style=background-image:url(https://aryido.github.io/images/background.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://aryido.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>