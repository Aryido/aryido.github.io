<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/posts/develop/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 14 Mar 2025 12:25:54 +0800</lastBuildDate><atom:link href="https://aryido.github.io/posts/develop/index.xml" rel="self" type="application/rss+xml"/><item><title>淺談 Concurrency 與 Asynchronous - 兩個常被一起提起的詞</title><link>https://aryido.github.io/posts/develop/concurrency-asynchronous/</link><pubDate>Fri, 14 Mar 2025 12:25:54 +0800</pubDate><guid>https://aryido.github.io/posts/develop/concurrency-asynchronous/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面基本介紹了 &lt;a href="https://aryido.github.io/posts/develop/process-thread/">Process 、 Thread&lt;/a> ，那其際的運作可以配合我們自己的常見的電腦使用情況來舉例，例如電腦操作系統的各種基本功能運行的「系統進程」、由 user 自己啓動的如 Word 文書應用程式的「用戶進程」; 再進一步的 Word 應用程式是可以同時進行「打字」、「拼寫檢查、「寫入硬碟儲存」等等工作，以上這些運作就是由「&lt;strong>多執行緒(Multithreading)&lt;/strong>」和「&lt;strong>多進程(Multiprocessing)&lt;/strong>」來達成的，基本上都是思考怎麼更&lt;strong>高效&lt;/strong>更&lt;strong>多工&lt;/strong>的處理多個不同的工作，這時 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非同步（Asynchronous）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>併發（Concurrency）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>兩個關鍵字會經常一起出現，是許多高效應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Process、Thread - 很重要的面試八股文</title><link>https://aryido.github.io/posts/develop/process-thread/</link><pubDate>Thu, 13 Mar 2025 19:27:31 +0800</pubDate><guid>https://aryido.github.io/posts/develop/process-thread/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>電腦運行時&lt;strong>任務的的單元是什麼呢&lt;/strong>？ 這個涉及了「程式(Program)」、「進程(Process)」、「線程(Thread)」的概念，是面試時經常會被問到的題目，首先&lt;strong>默念默背&lt;/strong>一下教科書上 Process 和 Thread 的簡單定義：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Process： 資源分配的最小單位&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Thread： CPU 執行的最小單位&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在實際生活中如點開一個聊天應用程式，這就是將 Program 活化成 Process 的例子，因此我們可以在電腦的資源管理器 Monitor 中看到 PID (Process ID) ; 再繼續以聊天室 Process 為例，我們可以同時「接受對方傳來的訊息」以及「發送自己的訊息給對方」，這就是同個 Process 中不同 Thread 的功勞。&lt;/p>
&lt;/blockquote></description></item><item><title>Homebrew 介紹和常用操作</title><link>https://aryido.github.io/posts/develop/homebrew/</link><pubDate>Mon, 20 May 2024 19:38:28 +0800</pubDate><guid>https://aryido.github.io/posts/develop/homebrew/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Homebrew 是一個廣泛使用在 MAC 上的&lt;strong>套件管理工具&lt;/strong>，可以安裝一些 Mac App Store 上沒有的軟體，其操作十分方便，可以簡化軟體安裝的過程，是個很有名的&lt;strong>非官方工具&lt;/strong>，由 Max Howell 以 Git 和 Ruby 為基底寫成，並通過 GitHub 維護，為 2012 年 GitHub 上擁有最多新貢獻者的專案。對於其作者也有個有趣的軼事：Max Howell 曾應聘過 Google 的職位，面試失敗之後在 Twitter 上發文章 :&lt;/p>
&lt;ul>
&lt;li>Google: 90% of our engineers use the software you wrote (Homebrew), but you can&amp;rsquo;t invert a binary tree on a whiteboard so f*** off.&lt;/li>
&lt;/ul>
&lt;p>因此在網上引發了面試白板題的討論。&lt;/p>
&lt;/blockquote></description></item><item><title>Opentelemetry 緣起簡介</title><link>https://aryido.github.io/posts/develop/opentelemetry-hisotry/</link><pubDate>Sun, 17 Mar 2024 11:17:16 +0800</pubDate><guid>https://aryido.github.io/posts/develop/opentelemetry-hisotry/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>OpenTelemetry ，也稱為 OTel，是 Cloud Native Computing Foundation(CNCF) 下的一個開源專案，為一供應商中立(vendor-neutral)的&lt;strong>可觀測性框架&lt;/strong>，目的是提供一個&lt;strong>標準化&lt;/strong>Observability 的 pluggable 框架，解決 telemetry data 的模型定義、檢測、採集、處理、輸出等一致性問題。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/monitoring/opentelemetry-architecture.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/monitoring/opentelemetry-architecture.jpg" >
&lt;/a>
&lt;/div>
借助 OpenTelemetry ，可以從各種來源收集 telemetry data ，但對於資料的存儲和可視化是留給其他工具的，本身並不提供儲存，只能將其發送到其他的服務來存儲，如 Prometheus、或其他雲端廠商服務。&lt;/p>
&lt;/blockquote></description></item><item><title>Regular Expression 簡介</title><link>https://aryido.github.io/posts/develop/regular-expression-intro/</link><pubDate>Fri, 26 Jan 2024 21:19:20 +0800</pubDate><guid>https://aryido.github.io/posts/develop/regular-expression-intro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Regular Expression 是一種強大的&lt;strong>字串匹配&lt;/strong>、&lt;strong>字串查找&lt;/strong>等操作工具，常簡寫爲 regex 、regexp 或 RE。這概念最初由 Unix 的 sed、grep 操作而普及開，它定義一系列&lt;strong>符號&lt;/strong>來描述搜索的規則。
但在不同的 coding language 或者是不同 OS 中， 常發現 regex 都會有些差異，主要原因是演進過程中，出現 &lt;strong>POSIX&lt;/strong> 與 &lt;strong>PCRE&lt;/strong> 兩種 :&lt;/p>
&lt;ul>
&lt;li>
&lt;p>POSIX : 可以說是原初版本，主要用於 UNIX 系統的文本處理，grep 、sed 、awk 等都屬之&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PCRE : 現代 coding language如 Python、Ruby、 C、C++、Java 都屬於 PCRE 派系。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Fluent Bit 基礎介紹</title><link>https://aryido.github.io/posts/develop/fluent-bit-intro/</link><pubDate>Wed, 24 Jan 2024 20:40:16 +0800</pubDate><guid>https://aryido.github.io/posts/develop/fluent-bit-intro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Fluent Bit 是一款使用 C 語言編寫的開源的資料收集器，為 Fluentd 的輕量化版本，也是 Cloud Native Computing Foundation(雲原生運算基金會) 下的一個子項目。可以從&lt;strong>多種不同來源&lt;/strong>【如 Log file、kafka 等等】，收集 Logs、Metrics、 Traces 資料，然後輸出至&lt;strong>多種不同的服務&lt;/strong> 【如 Loki、Fluentd、Elasticsearch、DataDog、Kafka 以及各式雲端服務】。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/monitoring/fluent-bit-2.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/monitoring/fluent-bit-2.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>Rolling vs Canary vs Blue-Green</title><link>https://aryido.github.io/posts/develop/rolling-canary-bluegreen/</link><pubDate>Wed, 17 May 2023 00:26:34 +0800</pubDate><guid>https://aryido.github.io/posts/develop/rolling-canary-bluegreen/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現今應用程式發展迅速， app 的更新也變得越來越頻繁，在微服務、DevOps、Cloud-native 的迭代過程中，最終都需要上線。上線就需要部署；需要部署就意味著有修改；修改則意味著有風險，要如何在&lt;strong>盡量不影響 user 的前提下，讓 app 升版呢&lt;/strong> ? 這時就有一些&lt;strong>部屬策略&lt;/strong>可以考慮。對於 Deployment Strategies 有一些基本的專有名詞和觀念，例如 :&lt;/p>
&lt;ul>
&lt;li>Recreate&lt;/li>
&lt;li>Rolling&lt;/li>
&lt;li>Blue-Green&lt;/li>
&lt;li>Canary&lt;/li>
&lt;/ul>
&lt;p>對於應該使用哪種 Deployment Strategy 、它們的工作原理、優缺點等等，以下會做些基本介紹。&lt;/p>
&lt;/blockquote></description></item><item><title>cloc: code line 統計工具</title><link>https://aryido.github.io/posts/develop/cloc/</link><pubDate>Sat, 22 Apr 2023 13:25:32 +0800</pubDate><guid>https://aryido.github.io/posts/develop/cloc/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>cloc 全名是 &lt;strong>Count Lines of Code&lt;/strong> ， 為一個計算 code 和設定檔&lt;strong>行數&lt;/strong>的 CLI 工具，是使用 Perl 語言開發的開源統計工具。cloc 支援非常多程式語言、平台、格式的統計，可以快速地計算一個 project 中所有文件的行數、空行、註釋行等等。有時候在寫一些報告會用到，可以幫助整理資料。&lt;/p>
&lt;/blockquote></description></item><item><title>apt、yum、apk 介绍</title><link>https://aryido.github.io/posts/develop/apt-yum-apk/</link><pubDate>Wed, 22 Mar 2023 22:58:26 +0800</pubDate><guid>https://aryido.github.io/posts/develop/apt-yum-apk/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Linux 有多種流通版本，例如常見的 Ubuntu、Debian、CentOS、Fedora、Red Hat 等等，其中裡面預設的&lt;strong>包管理系統&lt;/strong>也不太一樣。包管理系統可以&lt;strong>安裝 package&lt;/strong> 、&lt;strong>更新 package&lt;/strong> 、確保使用的 &lt;strong>package 是經過審查的&lt;/strong>。 接下來淺淺的分析 apt 、 yum 、 apk 之間的差別。&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - cloud run 出現錯誤</title><link>https://aryido.github.io/posts/develop/m1-error-2/</link><pubDate>Sun, 08 Jan 2023 21:54:38 +0800</pubDate><guid>https://aryido.github.io/posts/develop/m1-error-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Run 是 Google 的 Serverless 產品，讓我們不用管理基礎 infra 也能建置容器，並會根據流量自動調整資源，且只依據實際使用的資源收費。 這邊特別注意一下，目前 Cloud Run 似乎還沒支持 ARM 格式的 image，故有使用 M1 筆電包 docker image 要特別注意一下，這會出現不可預期的 bug !&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - CPU 簡介</title><link>https://aryido.github.io/posts/develop/m1-error-1/</link><pubDate>Wed, 04 Jan 2023 23:02:30 +0800</pubDate><guid>https://aryido.github.io/posts/develop/m1-error-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在公司很多都會給新進員工配上 Apple M1 筆電，整體筆電用起來都還不錯的。但因為 Apple M1 底層處理器架構大改變，對於軟體開發在本地端測試時候，常發生一些不可預期的狀況。這邊就來記錄一下有遇到的 BUG。&lt;/p>
&lt;/blockquote></description></item><item><title>CIDR 介紹</title><link>https://aryido.github.io/posts/develop/cidr/</link><pubDate>Sun, 13 Nov 2022 17:37:27 +0800</pubDate><guid>https://aryido.github.io/posts/develop/cidr/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>無類別域間路由（ Classless Inter-Domain Routing ，簡稱 CIDR ）是為了避免造成 IP 位址的大量浪費，於是出現的一種技術。CIDR重點有：&lt;/p>
&lt;ol>
&lt;li>多變長度子網路遮罩 (Variable-Length Subnet Mask，VLSM)&lt;/li>
&lt;li>路由匯總 （Route Summarization）(暫不介紹)&lt;/li>
&lt;/ol>
&lt;/blockquote></description></item><item><title>IP and Subnet Mask 介紹</title><link>https://aryido.github.io/posts/develop/ip-and-subnetmask/</link><pubDate>Mon, 07 Nov 2022 22:55:14 +0800</pubDate><guid>https://aryido.github.io/posts/develop/ip-and-subnetmask/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>IP (Internet Protocol) 是電腦的地址。IP 位址在系統中是一個 32 位元的數字，但為了方便人類讀寫，每一個位元組會被轉換成一個十進位的數字。&lt;/p>
&lt;p>IP 位址可以分為 Network ID 和 Host ID，為了讓電腦可以判斷出 IP 位址的 Network ID 及 Host ID，必須靠子網路遮罩 (Subnet Mask) 的幫忙。&lt;/p>
&lt;/blockquote></description></item></channel></rss>