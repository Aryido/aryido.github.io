<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"淺談 Concurrency 與 Asynchronous","image":"https://aryido.github.io/images/others/os.jpg","datePublished":"2025-03-14T12:25:54+08:00","dateModified":"2025-03-14T12:25:54+08:00","author":{"@type":"Person","name":"李昀陽 YunYang Lee","image":"https://aryido.github.io/images/aboutme/head-shot.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/aryido.github.io\/posts\/develop\/concurrency-asynchronous\/"},"publisher":{"@type":"Organization","name":"Aryido Tech Note","logo":{"@type":"ImageObject","url":"https://aryido.github.io/images/aboutme/head-shot.jpg"}},"description":" 前面基本介紹了 Process 、 Thread，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「多執行緒(Multithreading)」和「多進程(Multiprocessing)」來協調達成的，再來是要如何更高效更多工的處理多個不同的工作，變成是經常需要思考的問題，這時 :\n非同步（Asynchronous） : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分 併發（Concurrency） : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生 兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.119.0 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="李昀陽 YunYang Lee"><meta name=keywords content><meta name=description content="

前面基本介紹了 Process 、 Thread，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「多執行緒(Multithreading)」和「多進程(Multiprocessing)」來協調達成的，再來是要如何更高效更多工的處理多個不同的工作，變成是經常需要思考的問題，這時 :

非同步（Asynchronous） : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分
併發（Concurrency） : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生

兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。
"><meta property="og:description" content="

前面基本介紹了 Process 、 Thread，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「多執行緒(Multithreading)」和「多進程(Multiprocessing)」來協調達成的，再來是要如何更高效更多工的處理多個不同的工作，變成是經常需要思考的問題，這時 :

非同步（Asynchronous） : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分
併發（Concurrency） : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生

兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。
"><meta property="og:type" content="article"><meta property="og:title" content="淺談 Concurrency 與 Asynchronous"><meta name=twitter:title content="淺談 Concurrency 與 Asynchronous"><meta property="og:url" content="https://aryido.github.io/posts/develop/concurrency-asynchronous/"><meta property="twitter:url" content="https://aryido.github.io/posts/develop/concurrency-asynchronous/"><meta property="og:site_name" content="Aryido Tech Note"><meta property="og:description" content="

前面基本介紹了 Process 、 Thread，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「多執行緒(Multithreading)」和「多進程(Multiprocessing)」來協調達成的，再來是要如何更高效更多工的處理多個不同的工作，變成是經常需要思考的問題，這時 :

非同步（Asynchronous） : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分
併發（Concurrency） : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生

兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。
"><meta name=twitter:description content="

前面基本介紹了 Process 、 Thread，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「多執行緒(Multithreading)」和「多進程(Multiprocessing)」來協調達成的，再來是要如何更高效更多工的處理多個不同的工作，變成是經常需要思考的問題，這時 :

非同步（Asynchronous） : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分
併發（Concurrency） : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生

兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。
"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2025-03-14T12:25:54"><meta property="article:modified_time" content="2025-03-14T12:25:54"><meta property="article:section" content="develop"><meta property="article:tag" content="asynchronous"><meta name=twitter:card content="summary"><meta property="og:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="og:image" content="https://aryido.github.io/images/others/os.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/others/os.jpg"><title>淺談 Concurrency 與 Asynchronous</title><link rel=icon href=https://aryido.github.io/favicon.png><link rel=canonical href=https://aryido.github.io/posts/develop/concurrency-asynchronous/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://aryido.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://aryido.github.io/ aria-label="Go to homepage">Aryido Tech Note</a></div><a class=header-right-picture href=https://aryido.github.io/#about aria-label="Open the link: /#about"><img class=header-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://aryido.github.io/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>李昀陽 YunYang Lee</h4><h5 class=sidebar-profile-bio>Welcome to my Tech Note. You can read some of the chapters below.</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/Aryido target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/index.xml title=RSS><i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden=true></i>
<span class=sidebar-button-desc>RSS</span></a></li></ul><ul class=sidebar-buttons></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>淺談 Concurrency 與 Asynchronous</h1><div class="postShorten-meta post-meta"><time datetime=2025-03-14T12:25:54+08:00>March 14, 2025</time>
<span>in</span>
<a class=category-link href=https://aryido.github.io/categories/develop>develop</a></div></div><div class="post-content markdown"><div class=main-content-wrap><blockquote><p>前面基本介紹了 <a href=https://aryido.github.io/posts/develop/process-thread/>Process 、 Thread</a>，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「<strong>多執行緒(Multithreading)</strong>」和「<strong>多進程(Multiprocessing)</strong>」來協調達成的，再來是要如何<strong>更高效更多工</strong>的處理多個不同的工作，變成是經常需要思考的問題，這時 :</p><ul><li><strong>非同步（Asynchronous）</strong> : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分</li><li><strong>併發（Concurrency）</strong> : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生</li></ul><p>兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。</p></blockquote><hr><p>雖然 Concurrency 與 Asynchronous 是兩個常同時一起提起的詞，但又很難說他們真的很相關，頗有一種<strong>相關係數是</strong> <code>0.38</code>的怪異&mldr;，到底算<strong>低度相關</strong>還是<strong>中相關</strong>有各個看法 ; 同理看來 Parallelism 和 Synchronous 一起看也是相當微妙呢 ! 但我解釋脈絡上還是會把它們放在一起同時說明，以下就來談一下吧 :</p><hr><h1 id=concurrency---常見翻譯--併發並發>Concurrency - 常見翻譯 : 併發、並發</h1><blockquote><p><strong>Concurrency 是指在同一時間範圍內處理多個任務。另外注意這些任務不一定要真正同時執行，而是可以交錯進行的。</strong></p></blockquote><p>實現 Concurrency 的技術中最容易理解的是「時間分片輪轉調度(Time-Slicing Round-Robin Scheduling)」，簡單說就是在操作系統的管理下所有正在運行的任務都 :</p><ul><li>輪流使用 CPU</li><li>每個任務允許佔用 CPU 的時間非常短 (比如 10 毫秒)</li></ul><p>由於切換得很快，故用戶可能根本感覺不出來 CPU 是在輪流爲多個任務服務，就好像所有的任務都在不間斷地運行一樣，但實際上在任何一個時間內有僅有一個任務佔有 CPU。以上的解釋比較是屬於從 「CPU 運行的角度」來說明，若從 「Thread 的角度」去談， Multi-Thread 間彼此需要協調等待，交出 CPU 執行時間片的使用權，<strong>這也是一種 Concurrency 併發</strong>。</p><p>那再<strong>多核 CPU</strong> 情況下，如果任務數小於 CPU 數，且不同任務可以分配給不同的 CPU 來運行，讓多個任務達成「真正同時運行」，這就是所謂的 Parallelism。</p><ul><li><h2 id=parallelism---常見翻譯--平行併行>Parallelism - 常見翻譯 : 平行、併行</h2><blockquote><p>Parallelism 定義是要多個 Process/Thread <strong>同時平行處理多個任務</strong>，能夠利用「多核心 CPU」的數量特性，適合用在圖像處理、算法處理、機器學習等需大量計算，提高效率</p></blockquote></li></ul><p><strong>Concurrency 主要關注於任務的管理和調度</strong>，要在一時間段內處理多個任務，不論是通過時間片輪轉在單核處理器上切換進行，還是在多核處理器上水平並行。 Concurrency 和 Parallelism 會同時出現比較像是想對比 「交錯執行」 與 「同時進行」的概念。</p><div class="alert danger"><p><p>Parallelism 定義是要<strong>平行同時處理</strong>多個任務的 ; 而 Concurrency 的關鍵是有處理多個任務的能力，不一定要同時，所以可以說 <strong>Parallelism 是 Concurrency 的 subset</strong>，而 Parallelism 是提高 Concurrency 的一種實現方式。</p><p>如果真的要說 Parallelism 的反意詞，使用 Sequential Processing 或 Serial Processing 會是最準確的。但雖然是這樣說，偶爾還是會有人用 Concurrency 來當 Parallelism 的反意形容 &mldr; 溝通上要注意一下！</p></p></div><hr><h1 id=asynchronous-非同步異步>Asynchronous 非同步/異步</h1><blockquote><p><strong>任務可以「不阻塞」當前執行流程，允許程式繼續執行其他工作，並在未來某個時間點返回來繼續進行剩下的任務部分。</strong></p></blockquote><p>一般來說 Asynchronous 會使用在例如 I/O 等相對「慢」的操作任務上（與 CPU 和 RAM 速度相比的慢），實際舉例的話如下 :</p><ul><li><p>網絡資料的收發、遠端 API 操作<div class="alert info"><p>任務執行時間主要消耗在「等待」回應上</p></div></p></li><li><p>像磁盤文件讀寫、資料庫操作<div class="alert info"><p>任務執行時間主要消耗「I/O 操作」上，因此也稱為「<strong>I/O bound</strong>」</p></div></p></li></ul><p>以磁盤文件讀取寫入的 <strong>I/O 操作</strong>爲例，實際上是 code 通過系統調用的方式，向操作系統發出讀寫請求。以 read 函數爲例在 <strong>Synchronous</strong> 調用方式下，文件在讀取完之前 main thread 是無法繼續向前進的，只有當 read 函數返回後才可以繼續往後</p><div class="alert warning"><p>由於 Synchronous 也是按照順序調用執行，故也稱為 Sequential</p></div><p>若 read 函數以 <strong>Asynchronous</strong> 調用的話，那即使文件還沒有完全讀取完成，read 函數也可以執行接下來的 code，這就是異步的高效之處。</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/others/concurrency-asynchronous/concurrency.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/others/concurrency-asynchronous/concurrency.jpg></a></div><p>Asynchronous 主要關注於提高程式在「等待期間」的效率，允許程式在等待一個操作完成的同時，繼續執行其他任務，從而避免阻塞。</p><div class="alert info"><p>與此相對的，若大部分執行時間，都是實際運算工作而不是等待回應，因為計算機中的工作是由 CPU 完成的，因此可將這些問題稱為「<strong>CPU bound</strong>」。</p></div><h2 id=asynchronous-的實現方式-notify--callback>Asynchronous 的實現方式: Notify / Callback</h2><p>以常見的 Web 服務來舉例， 當 Web Server 接收到用戶請求，後續操作經常會做一些資料庫查詢之類的事情，故一般來說 Web Server 服務通常有兩個典型的 Thread ：</p><blockquote><ul><li>Main-Thread</li><li>DB-Thread</li></ul></blockquote><p>假定處理一次用戶請求，需要經過步驟 A、B、C，然後有「資料庫查詢請求」的操作，再來查詢請求完成後還要經過步驟 D、E、F，其中<strong>只有</strong>「資料庫查詢請求」這一步有涉及到 I/O、網絡通訊等等「<strong>慢操作</strong>」，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>mainThread<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    A<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    B<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    C<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    資料庫查詢請求<span style=color:#f92672>;</span> <span style=color:#75715e>// 慢操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    D<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    E<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    F<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>在最典型的 Synchronous 設計下，Main-Thread 在發出資料庫查詢請求後，就會「阻塞」等待直到資料庫查詢完畢並接受到回應資料，之後 D、E、F 才可以繼續運行，但<strong>顯然可以發現這並不夠高效</strong>，因為 Main-Thread 會有運行空隙，利用效率時還可以在增進的，如下圖是 Synchronous 示意 ：</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/others/concurrency-asynchronous/synchronous.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/others/concurrency-asynchronous/synchronous.jpg></a></div><p>這時候 Asynchronous 就是蠻好的優化方式，<strong>在 Asynchronous 實現下， Main-Thread 不用去等待資料庫是否查詢完成，而是發送完資料庫讀寫請求後直接處理下一個請求</strong>。</p><blockquote><p>在 Synchronous 同步調用下， Main-Thread 會被阻塞，等到被調函數執行完後很自然的就是繼續執行 ; 相比之下 Asynchronous 非同步調用下， Main-Thread 可以直接就去處理下個請求了。</p><p>那麼接下來思考一下，在 Asynchronous 調用下「調用方」怎知道「被調函數」是否執行完成呢？</p></blockquote><p>承上面範例來說， Main-Thread 在完成 A、B、C、資料庫查詢後，直接處理接下來的請求了，那麼上一個請求中剩下的 D、E、F 怎麼辦呢？這就是本節要說的 Notify & callback ，接下來那我們來討論一下處理 D、E、F 的需求情況，這可分爲了兩種需求模式：</p><ul><li>調用方<strong>不用關心</strong>執行結果</li><li>調用方<strong>必需要知道</strong>執行結果</li></ul><h3 id=回調函數-callback-function>回調函數 (callback function)</h3><p>在<strong>調用方不關心資料庫操作結果</strong>的情況下，我們可以簡單使用「<strong>回調 (callback)</strong>」機制來處理後續的 D、E、F 請求。例如我們可以將處理 D、E、F 這幾個步驟封裝到一個函數中，假定將該函數命名爲 <code>AfterDBQuery</code> :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>AfterDBQuery</span> <span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    D<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    E<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    F<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>主線程在發送資料庫查詢請求的同時，將該 <code>AfterDBQuery</code> 函數一併當做參數傳遞過去給 DB-Thread :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>DBQuery<span style=color:#f92672>(</span>request<span style=color:#f92672>,</span> AfterDBQuery<span style=color:#f92672>);</span>
</span></span></code></pre></div><p>DB-Thread 處理完查詢請求後，DB-Thread 可以就直接調用 <code>AfterDBQuery</code> 來執行操作，而這個函數就是所謂的「<strong>回調函數</strong>」。</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/others/concurrency-asynchronous/callback.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/others/concurrency-asynchronous/callback.jpg></a></div><div class="alert warning"><p>DB-Thread 需要做的僅僅就是查詢資料、然後調用 callback function ，至於這個 callback function 做了些什麼 DB-Thread 不用關心也不應該關心，因為只有使用方知道資料查詢完後該做些什麼，故從系統設計上來講，<strong>接下來要做什麼這件事情，不應該是 DB-Thread 來定義的</strong>，因此 DB-Thread 只要簡單的執行傳入的 callback function 就可以了，而不是自己去詳細定義要做什麼。</p></div><h3 id=通知機制notify>通知機制(Notify)</h3><p>在 <strong>Main-Thread 需要知道資料庫操作結果才能進行下一步</strong>的情況下，需要使用「<strong>通知機制(Notify)</strong>」機制， DB-Thread 需要將查詢結果利用通知機制發送給 Main-Thread ，而 Main-Thread 在接收到消息後回頭繼續處理上一個請求的後半部分，示意圖就像這樣 :</p><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/others/concurrency-asynchronous/notify.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/others/concurrency-asynchronous/notify.jpg></a></div><div class="alert info"><p>從這裏我們可以看到，ABCDEF 幾個步驟全部都由 Main-Thread 處理</p></div><div class="alert danger"><p>雖然上面的 Asynchronous 舉例都是多執行緒的，但<strong>Asynchronous 也可以單執行緒執行</strong>，例如 Python 的 <code>asyncio</code> 就是用一個 Main-Thread 單執行緒達成非同步機制</p></div><hr><h3 id=參考資料>參考資料</h3><ul><li><p><a href=https://www.readfog.com/a/1712359196368932864>徹底理解什麼是同步和異步！</a></p></li><li><p><a href=https://www.cnblogs.com/zimug/p/13660326.html>图解并发与并行-分别从 CPU 和线程的角度理解</a></p></li><li><p><a href=https://davidleitw.github.io/posts/concurrency01/>Concurrency vs Parallelism 淺談兩者區別以及名詞介紹</a></p></li><li><p><a href=https://www.sohu.com/a/754341569_121124363>一張圖讀懂併發/並行/異步的區別</a></p></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://aryido.github.io/tags/asynchronous/>asynchronous</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/develop/process-thread/ data-tooltip="淺談 Process、Thread" aria-label="PREVIOUS: 淺談 Process、Thread"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 李昀陽 YunYang Lee. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/develop/process-thread/ data-tooltip="淺談 Process、Thread" aria-label="PREVIOUS: 淺談 Process、Thread"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"><h4 id=about-card-name>李昀陽 YunYang Lee</h4><div id=about-card-bio>Welcome to my Tech Note. You can read some of the chapters below.</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Software Engineer</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Taiwan</div></div></div><div id=cover style=background-image:url(https://aryido.github.io/images/background.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://aryido.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>