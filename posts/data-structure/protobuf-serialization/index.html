<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protobuf - 序列化反序列化詳解","image":"https://aryido.github.io/images/data-structure/protobuf.jpg","datePublished":"2024-05-01T22:10:30+08:00","dateModified":"2024-05-01T22:10:30+08:00","author":{"@type":"Person","name":"李昀陽 YunYang Lee","image":"https://aryido.github.io/images/aboutme/head-shot.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/aryido.github.io\/posts\/data-structure\/protobuf-serialization\/"},"publisher":{"@type":"Organization","name":"Aryido Tech Note","logo":{"@type":"ImageObject","url":"https://aryido.github.io/images/aboutme/head-shot.jpg"}},"description":" 現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 .proto 檔案，就可以生成不同的程式語言來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :\nVarint Encoding Zigzag Encoding Wire Type 類型 T-L-V 儲存方式 熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.119.0 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="李昀陽 YunYang Lee"><meta name=keywords content><meta name=description content="

現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 .proto 檔案，就可以生成不同的程式語言來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :

Varint Encoding
Zigzag Encoding
Wire Type 類型
T-L-V 儲存方式

熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。
"><meta property="og:description" content="

現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 .proto 檔案，就可以生成不同的程式語言來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :

Varint Encoding
Zigzag Encoding
Wire Type 類型
T-L-V 儲存方式

熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。
"><meta property="og:type" content="article"><meta property="og:title" content="Protobuf - 序列化反序列化詳解"><meta name=twitter:title content="Protobuf - 序列化反序列化詳解"><meta property="og:url" content="https://aryido.github.io/posts/data-structure/protobuf-serialization/"><meta property="twitter:url" content="https://aryido.github.io/posts/data-structure/protobuf-serialization/"><meta property="og:site_name" content="Aryido Tech Note"><meta property="og:description" content="

現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 .proto 檔案，就可以生成不同的程式語言來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :

Varint Encoding
Zigzag Encoding
Wire Type 類型
T-L-V 儲存方式

熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。
"><meta name=twitter:description content="

現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 .proto 檔案，就可以生成不同的程式語言來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :

Varint Encoding
Zigzag Encoding
Wire Type 類型
T-L-V 儲存方式

熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。
"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2024-05-01T22:10:30"><meta property="article:modified_time" content="2024-05-01T22:10:30"><meta property="article:section" content="data-structure"><meta property="article:tag" content="protobuf"><meta property="article:tag" content="data-exchange"><meta name=twitter:card content="summary"><meta property="og:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/aboutme/head-shot.jpg"><meta property="og:image" content="https://aryido.github.io/images/data-structure/protobuf.jpg"><meta property="twitter:image" content="https://aryido.github.io/images/data-structure/protobuf.jpg"><title>Protobuf - 序列化反序列化詳解</title><link rel=icon href=https://aryido.github.io/favicon.png><link rel=canonical href=https://aryido.github.io/posts/data-structure/protobuf-serialization/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://aryido.github.io/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://aryido.github.io/ aria-label="Go to homepage">Aryido Tech Note</a></div><a class=header-right-picture href=https://aryido.github.io/#about aria-label="Open the link: /#about"><img class=header-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://aryido.github.io/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>李昀陽 YunYang Lee</h4><h5 class=sidebar-profile-bio>Welcome to my Tech Note. You can read some of the chapters below.</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/Aryido target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://aryido.github.io/index.xml title=RSS><i class="sidebar-button-icon fas fa-lg fa-rss" aria-hidden=true></i>
<span class=sidebar-button-desc>RSS</span></a></li></ul><ul class=sidebar-buttons></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>Protobuf - 序列化反序列化詳解</h1><div class="postShorten-meta post-meta"><time datetime=2024-05-01T22:10:30+08:00>May 1, 2024</time>
<span>in</span>
<a class=category-link href=https://aryido.github.io/categories/data-structure>data-structure</a></div></div><div class="post-content markdown"><div class=main-content-wrap><blockquote><p>現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 <strong>.proto</strong> 檔案，就可以生成<strong>不同的程式語言</strong>來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :</p><ul><li>Varint Encoding</li><li>Zigzag Encoding</li><li>Wire Type 類型</li><li>T-L-V 儲存方式</li></ul><p>熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。</p></blockquote><hr><p>之前有對 <a href=https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/>protobuf 做過基礎的介紹</a>，而 Protobuf 是通過 Varint 和 Zigzag 來大幅減少了 Value 佔用的儲存空間，可參考前面 <a href=https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/>Varint & Zigzag Encoding 介紹</a>。Protocol Buffers 做為一種<strong>資料交換格式</strong>，主要有兩個面相：</p><ul><li>定義了一種介面描述語言 (Interface Description Language)，用來描述需要交換的資料結構</li><li>定義了一種 serialization-deserialization 模式</li></ul><p>本篇介紹 Protobuf 的 serialization-deserialization。</p><hr><h1 id=serialization>Serialization</h1><p>Protobuf encode 後二進制表示法結構，就是<strong>多個 field 組成</strong>的。下面我們就針對不同的 WireType，來一個個分析 Protocol Buffers 不同 WireType 的序列化方式 :</p><h3 id=wiretype--0-1-5>WireType = 0, 1, 5</h3><div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/data-structure/protobuf-wiretype-015.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/data-structure/protobuf-wiretype-015.jpg></a></div><ul><li><p>int32: <code>WireType = 0</code>，其 Value 是整數字且會用 Varint 編碼，因此編碼自帶長度訊息，<strong>最多會使用到 8 個 bytes</strong>。</p></li><li><p>double: <code>WireType = 1</code>，其 Value 固定 8 bytes，是採用雙精確度浮點數 <code>IEEE 754</code>。</p></li><li><p>float: <code>WireType = 5</code>，其 Value 固定 4 bytes。</p></li></ul><div class="alert success"><p>因為以上這幾種類型都不需要再多一個 byte 來說明 Length，故更好的利用了空間。</p></div><h3 id=wiretype--2>WireType = 2</h3><p>這種 WireType 會多了一個 Length，用於標識 Value 的長度，其中 Value 又區分成幾種類型：</p><ul><li><p>String 類型，是使用 UTF8 編碼<div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-string.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-string.jpg></a></div></p></li><li><p>嵌套另一個 Protobuf Message 類型<div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-message.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-message.jpg></a></div></p></li><li><p>有 repeat label<div class="figure fig-100"><a class=fancybox href=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-repeated.jpg data-fancybox><img class=fig-img src=https://aryido.github.io/images/data-structure/protobuf-wiretype-2-repeated.jpg></a></div><code>proto2</code> 才會需要寫上 <code>packed=true</code>；在 <code>proto3</code> 中數字類如 int32、int64 等等有標上 repeated 的 field 默認使用 packed 編碼，<strong>會專門針對數字類型做的一個編碼空間優化策略</strong>，它會把 Tag 完全一樣的 value 打包在一起。<div class="alert success"><p>沒有 packed 的 repeat 數字，標瑪模式都是 Tag-Value 接續 Tag-Value 持續下去，但其實它們有着一樣的 tag，所以可以巧妙的使用 T-L-V 存儲方式，Length 代表 Value 列表的<strong>總字節長度</strong>，不需要每個 Value 前面放個相同的 Tag，極大的節省了空間。</p></div></p></li></ul><div class="alert warning"><p>如果原始資料的某個 field 沒有被附加上值，那麼序列化後的 byte array 就會完全不存在相關資訊，相應 field 在反序列化時會被設置爲<strong>默認值</strong>。</p></div><h1 id=deserialization>Deserialization</h1><p>直接來練習一下吧! 我是拿這個網站 <a href=https://zddhub.com/note/2021/07/25/protobuf.html>zddhub</a> 內範例題目，首先有一個新的 <code>.proto</code> 檔定義如下:</p><pre tabindex=0><code>message Award {
  int64 id = 1;
  string code_book = 4;

  message Bonus {
    repeated int32 indexes = 24;
  }

  Bonus bonus = 128;
  double magic = 2048;
}
</code></pre><p>有個資料已經被 protobuf 編碼為二進制 :</p><pre tabindex=0><code>00001000 10110111 01001010 00100010 00011110 01100001
01100010 01100011 01100100 01100101 01100110 01100111
01101000 01101001 01101010 01101011 01101100 01101101
01101110 01101111 01110000 01110001 01110010 01110011
01110100 01110101 01110110 01110111 01111000 01111001
01111010 00101100 00100001 00111111 00100000 10000010
00001000 00101011 01010010 00000100 00000101 00000000
00001010 00000100 11000010 00000001 00100010 00011000
00001110 00010100 00011101 00000000 00010001 00000100
00011101 00000000 00010110 00000100 00010010 00001110
00001100 00000100 00011011 00011101 00010110 00000100
00000010 00000111 00000000 00010011 00011101 00001100
00000100 00011100 00011101 00011001 00000011 00000011
00000111 00010100 00000001 10000001 10000000 00000001
00000000 00000000 00000000 00000000 00000000 10000000
00100100 01000000
</code></pre><p>由於 string 直接用 ASCII 碼存儲，直接查看二進制就解密了，所以做了一個 code_book ，透過下標對應到密碼本上。例如 <code>indexes = [7, 4, 11, 11, 14, 29, 22, 14, 17, 3, 27] = hello word</code>，那這邊例題密碼本稍微不太一樣，以下實際來解密它 :</p><p>因為 Protobuf 編碼是依照 T-[L]-V 串聯而成，第一個 byte 一定是 tag。</p><ul><li><p>第 1 個 byte <code>00001000</code>，最高位元是 <code>0</code>，表示該 tag 僅以一個位元組表示。 <code>field number = 1</code>，<code>wiretype = 0</code> 代表 Varint ，故接下來是 value。</p></li><li><p>第 2 個 byte <code>10110111</code>，最高位元為 <code>1</code>，表示該 value 超過一個 byte ，繼續看下一個。</p></li><li><p>第 3 個 byte <code>01001010 </code>，此時最高位元為 <code>0</code>，該 value 以兩個 byte 表示，把順序反過來為，並去掉最高位標示 : <code>1001010 0110111</code> 為一個 value 的表示。</p></li><li><p>第 4 個 byte <code>00100010</code>，最高位元是 <code>0</code>，表示該 tag 僅以一個位元組表示。 field number 是 <code>00100</code>代表 <code>4</code>，<code>wiretype = 2</code> 代表 T-L-V ，故接下來是 length。</p></li><li><p>第 5 個 byte <code>00011110</code>，代表長度為 30，故接下來 30 個，即第 6 ~ 35 個 byte 都是 value :</p><pre tabindex=0><code>01100001
01100010 01100011 01100100 01100101 01100110 01100111
01101000 01101001 01101010 01101011 01101100 01101101
01101110 01101111 01110000 01110001 01110010 01110011
01110100 01110101 01110110 01110111 01111000 01111001
01111010 00101100 00100001 00111111 00100000
</code></pre><p>看起來是代表 <code>a~z,!? </code>，<strong>注意最後一個有空白鍵</strong>。</p></li><li><p>第 36 個 byte <code>10000010</code>，為一個新資料的 tag，因最高位元為 <code>1</code>，表示該 tag 超過一個 byte，繼續看下一個。</p></li><li><p>第 37 個 byte <code>00001000 </code>，因最高位元為 <code>0</code>，表示該 tag 結束，以兩個 byte 表示。把順序反過來為，並去掉最高位標示 : <code>0001000 0000010</code> 為一個 tag 的真實表示。其中 <code>wiretype = 2</code>，是 T-L-V ，故接下來是<strong>長度</strong>；而 field number = <code>10000000</code> = 128。</p></li><li><p>第 38 個 byte <code>00101011</code> = 43，故接下來 43 個，即第 39 ~ 81 個 byte 都是 value :</p><pre tabindex=0><code>01010010 00000100 00000101 00000000
00001010 00000100 11000010 00000001 00100010 00011000
00001110 00010100 00011101 00000000 00010001 00000100
00011101 00000000 00010110 00000100 00010010 00001110
00001100 00000100 00011011 00011101 00010110 00000100
00000010 00000111 00000000 00010011 00011101 00001100
00000100 00011100 00011101 00011001 00000011 00000011
00000111 00010100 00000001
</code></pre></li><li><p>第 39 個 byte <code>01010010</code> 代表 tag，<code>wiretype=2</code>，知道下一個 byte 代表長度，且 <code>field number = 10</code>，但沒有在 <code>.proto</code>中定義，故等等之後 value 會省略不解析</p></li><li><p>第 49 個 byte <code>00000100</code> = 4，承上接下來 4 個 byte 都捨棄不解析，所以 50~53 byte :</p><pre tabindex=0><code>00000101 00000000
00001010 00000100
</code></pre><p>都不用解析，丟掉他們。<div class="alert info"><p>Protobuf 在解析時，主要都是看 <code>field number</code>。如果看到 Protobuf byte array 內有一個資料 T-[L]-V ，但是 schema 中沒有定義，其實並不會怎樣。雖然沒有辦法知道這個 field 名稱叫什麼，但是可以知道是什麼 type，同時也可以算出需要跳過多少個 bytes，以便找到的下一個 T-[L]-V。</p></div></p></li><li><p>第 54 個 byte <code>11000010</code> 代表 tag，但因最高位元為 <code>1</code>，表示該 tag 超過一個 byte，繼續看下一個。</p></li><li><p>第 55 個 byte <code>00000001</code>，也代表 tag，因最高位元為 <code>0</code>，表示該 tag 結束，故 tag 以兩個 byte 表示，把順序反過來為，並去掉最高位標示 : <code>0000001 1000010</code>，代表 <code>field number = 24</code>；<code>wiretype = 2</code>，然後又因為有 repeated ，故接下來代表長度，然後其後面 byte 都是指 value。</p></li><li><p>第 56 個 byte <code>00100010</code> ，代表長度 34。</p></li><li><p>接下來 34 個都是單字對應</p><pre tabindex=0><code>00011000
00001110 00010100 00011101 00000000 00010001 00000100
00011101 00000000 00010110 00000100 00010010 00001110
00001100 00000100 00011011 00011101 00010110 00000100
00000010 00000111 00000000 00010011 00011101 00001100
00000100 00011100 00011101 00011001 00000011 00000011
00000111 00010100 00000001
</code></pre><p><a href=https://tools.yeecord.com/zh-tw/base-converter/bin/dec>解析完之後，以數字表示如下，並加上空白</a>:</p><pre tabindex=0><code>(24 14 20) (0 17 4) (0 22 4 18 14 12 4 27) (22 4 2 7 0 19) (12 4 28) (25 3 3 7 20 1)
</code></pre><p>對上數字翻譯為:</p><blockquote><p><code>you are awesome! wechas le? zddhub</code> (wechas 代表中文微信)</p></blockquote></li><li><p>第 82 個 byte 為 tag， <code>10000001</code>，因最高位元為 <code>1</code>，表示該 tag 超過一個 byte ，繼續看下一個。</p></li><li><p>第 83 個 byte <code>10000000</code>，因最高位元為 <code>1</code>，繼續看下一個。</p></li><li><p>第 84 個 byte <code>00000001 </code>，因最高位元為 <code>0</code>，tag 結束。去掉最高位標示並重新排列後 <code>0000001 0000000 0000001</code>，故 field number 為 <code>100000000000</code> = 2048，
<code>wiretype = 1</code> ，下 8 個 bytes 表示為 double</p></li><li><p>第 85 ~ 93 個 byte 都是 value:</p><pre tabindex=0><code>00000000 00000000 00000000 00000000 00000000 10000000
00100100 01000000
</code></pre><p>為 <a href=https://www.binaryconvert.com/result_double.html?>1.025E1 = 10.25</a></p></li></ul><p>至此全部分析完，以上是整個反序列化的講解。</p><div class="alert success"><p>在解析 Protobuf data 時，序列化和反序列化都是基於 <code>.proto</code> 檔的，所以可以明確知道 type ，故會根據欄位的 WireType 以及其定義的類型來進行解碼。</p></div><hr><h3 id=參考資料>參考資料</h3><ul><li><p><a href=https://www.readfog.com/a/1668729653630701568>protobuf 是怎麼序列化的</a></p></li><li><p><a href=https://zddhub.com/note/2021/07/25/protobuf.html>Protocol Buffers</a></p></li><li><p><a href=https://blog.51cto.com/u_16213700/7706668>android 序列化Image 序列化 protobuf</a></p></li><li><p><a href=https://www.cnblogs.com/niuben/p/14212711.html>protobuf优缺点及编码原理</a></p></li></ul></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://aryido.github.io/tags/protobuf/>protobuf</a>
<a class="tag tag--primary tag--small" href=https://aryido.github.io/tags/data-exchange/>data-exchange</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/ data-tooltip="Protobuf - Encoding 結構" aria-label="PREVIOUS: Protobuf - Encoding 結構"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 李昀陽 YunYang Lee. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/ data-tooltip="Protobuf - Encoding 結構" aria-label="PREVIOUS: Protobuf - Encoding 結構"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://aryido.github.io/images/aboutme/head-shot.jpg alt="Author's picture"><h4 id=about-card-name>李昀陽 YunYang Lee</h4><div id=about-card-bio>Welcome to my Tech Note. You can read some of the chapters below.</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Software Engineer</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Taiwan</div></div></div><div id=cover style=background-image:url(https://aryido.github.io/images/background.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://aryido.github.io/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>