<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Aryido Tech Note</title><link>https://aryido.github.io/</link><description>Recent content on Aryido Tech Note</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 03 May 2025 20:13:38 +0800</lastBuildDate><atom:link href="https://aryido.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>快捷鍵筆記簿</title><link>https://aryido.github.io/posts/develop/hotkey/</link><pubDate>Sat, 03 May 2025 20:13:38 +0800</pubDate><guid>https://aryido.github.io/posts/develop/hotkey/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在現代開發環境中，熟練掌握各種工具的快捷鍵能顯著提升工作效率，本筆記整理了自己常用開發工具的基礎操作與進階快捷鍵，幫助更高效地進行開發工作。&lt;strong>由於自己現在開發主要環境都是使用 mac os，所以快捷鍵會以 mac 的鍵盤配置為主&lt;/strong>，筆記會列出的重點工具為 :&lt;/p>
&lt;ul>
&lt;li>&lt;code>MacOS Terminal&lt;/code>&lt;/li>
&lt;li>&lt;code>Visual Studio Code (VSCode)&lt;/code>&lt;/li>
&lt;li>&lt;code>Vim&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>然後可能也會補充一些 &lt;code>Windows PowerShell&lt;/code> 和 &lt;code>IntelliJ IDEA&lt;/code>。在日常開發中可有意識的多使用快捷鍵來加深記憶，若遺忘時這裡可以快速查看筆記，鞏固快捷鍵的知識。&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Type Hint</title><link>https://aryido.github.io/posts/python/type-hint/</link><pubDate>Sat, 26 Apr 2025 14:39:56 +0800</pubDate><guid>https://aryido.github.io/posts/python/type-hint/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們都知道 Python 是一個動態的語言，代表每一個 variable 是什麼型別是在 runtime 的時候決定的，雖然很靈活可是當 code 量級上去之後因爲類型不正確引發的錯誤也會逐漸增加。但 Python 也是可以做到型別要求的，就是使用 「 Type Hint 」 或者叫 「 Type Annotation 」，中文稱呼蠻多種的例如「型別標註」、「型別提示」等等。 若有寫 Type Hint 的話，比較現代的 IDE 都會有一些自動顯示或補全輔助 :
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/python/ide-hint.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/python/ide-hint.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;p>Python 的 Type Hint 是從&lt;code>3.5&lt;/code>開始萌芽逐漸引入直到現在，故有一些發展的歷史脈絡和演變，有一些寫法也漸漸更替，故簡單介紹和分析一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Coroutine 的核心 - Event-Loop</title><link>https://aryido.github.io/posts/python/event-loop/</link><pubDate>Sun, 16 Mar 2025 22:56:39 +0800</pubDate><guid>https://aryido.github.io/posts/python/event-loop/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Python 的 Coroutine 發展已經逐漸穩定成熟，已經成為了提升 Python 程式效能的優秀解決方案之一，在之前簡單介紹 &lt;a href="https://aryido.github.io/posts/python/async-await/">Coroutine 和 await/async&lt;/a> 時，我們在範例 code 中一直有用到一個 Python buildin 模組 &lt;code>asyncio&lt;/code>，它提供了一套完整的工具和接口，用於建立非同步應用程式，其核心是 Event-Loop，會追蹤所有註冊的任務，並根據任務的狀態調度它們的執行。 故接著來了解 Event-Loop 和其工作的執行單位 Task 吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Python : Coroutine 和 async/await</title><link>https://aryido.github.io/posts/python/async-await/</link><pubDate>Sat, 15 Mar 2025 19:46:08 +0800</pubDate><guid>https://aryido.github.io/posts/python/async-await/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前有介紹了 &lt;a href="https://aryido.github.io/posts/develop/concurrency-asynchronous/">Asynchronous&lt;/a> ，而 Python 的 &lt;strong>Coroutine 是實現 Asynchronous 的一種設計方式&lt;/strong>，且 Python 目前已經有非常直觀簡單的語法糖來定義 Asynchronous Code，使得程式寫起來就像普通的 「 Sequential Processing 順序執行 」任務那樣，但同時卻也可以對&lt;strong>目標函數標註做「等待」的動作，並在「等待」期間可以先去做其他任務&lt;/strong>，達成非同步的功效，提高程式的並發性，而其重要的關鍵字就是 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>async&lt;/code> : 用來宣告 function 能夠有異步的功能成為 Coroutine function&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;code>await&lt;/code> : 用來標記 Coroutine 切換暫停和繼續的位置&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>而這兩個關鍵字是在 &lt;code>Python3.5&lt;/code> 引入且在 &lt;code>Python3.7&lt;/code> 成為&lt;strong>保留關鍵字&lt;/strong>。它們在著名的 FastAPI 框架下的 path operation function 下也經常使用，接下來就簡單介紹一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Concurrency 與 Asynchronous</title><link>https://aryido.github.io/posts/develop/concurrency-asynchronous/</link><pubDate>Fri, 14 Mar 2025 12:25:54 +0800</pubDate><guid>https://aryido.github.io/posts/develop/concurrency-asynchronous/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面基本介紹了 &lt;a href="https://aryido.github.io/posts/develop/process-thread/">Process 、 Thread&lt;/a>，而在現實世界中 Process 、 Thread 的任務是更加複雜的，都會是需要「&lt;strong>多執行緒(Multithreading)&lt;/strong>」和「&lt;strong>多進程(Multiprocessing)&lt;/strong>」來協調達成的，再來是要如何&lt;strong>更高效更多工&lt;/strong>的處理多個不同的工作，變成是經常需要思考的問題，這時 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非同步（Asynchronous）&lt;/strong> : 執行 Non-blocking 操作，允許程式在等待某些操作完成時可執行其他任務，之後可再回頭處理之前等待操作剩下的部分&lt;/li>
&lt;li>&lt;strong>併發（Concurrency）&lt;/strong> : 是系統能夠在一段時間內處理多個任務，這些任務可能交錯執行，不一定要同時發生&lt;/li>
&lt;/ul>
&lt;p>兩個關鍵字會經常一起出現，因為 Concurrency + Asynchronous 是許多高效能應用的關鍵，接下來就簡單談一下吧！另外可以稍微注意一下其他相關名詞的中文英文對照。&lt;/p>
&lt;/blockquote></description></item><item><title>淺談 Process、Thread</title><link>https://aryido.github.io/posts/develop/process-thread/</link><pubDate>Thu, 13 Mar 2025 19:27:31 +0800</pubDate><guid>https://aryido.github.io/posts/develop/process-thread/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>電腦運行時&lt;strong>任務的的單元是什麼呢&lt;/strong>？ 這個涉及了「程式(Program)」、「進程(Process)」、「線程(Thread)」的概念，是面試時經常會被問到的題目，首先&lt;strong>默念默背&lt;/strong>一下教科書上 Process 和 Thread 的簡單定義：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Process： 資源分配的最小單位&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Thread： CPU 執行的最小單位&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>在實際生活中如點開一個聊天應用程式，這就是將 Program 活化成 Process 的例子，因此我們可以在電腦的資源管理器 Monitor 中看到 PID (Process ID) ; 再繼續以聊天室 Process 為例，我們可以同時「接受對方傳來的訊息」以及「發送自己的訊息給對方」，這就是同個 Process 中不同 Thread 的功勞。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - 概述</title><link>https://aryido.github.io/not-yet-finished/shared-responsibility/</link><pubDate>Mon, 14 Oct 2024 00:23:58 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/shared-responsibility/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : ****&lt;/li>
&lt;li>Microsoft Azure : ****&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>GCP - Cloud Build 概述</title><link>https://aryido.github.io/not-yet-finished/cloud-build/</link><pubDate>Sun, 13 Oct 2024 23:50:08 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/cloud-build/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : ****&lt;/li>
&lt;li>Microsoft Azure : ****&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>GCP - 概述</title><link>https://aryido.github.io/not-yet-finished/dataproc/</link><pubDate>Fri, 11 Oct 2024 20:21:20 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/dataproc/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : ****&lt;/li>
&lt;li>Microsoft Azure : ****&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>GCP - Cloud VPN &amp; Cloud Interconnect 概述</title><link>https://aryido.github.io/not-yet-finished/cloud-vpn/</link><pubDate>Thu, 10 Oct 2024 18:18:34 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/cloud-vpn/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud VPN 全稱是 Cloud Virtual Private Network，能夠將 On-premise Network 和 GCP VPC Network 連接在一起，流量透過 IPSec 協議進行加密。而 Cloud Interconnect 可以說是加強版的 Cloud VPN，它是真的從你 On-premise 的設備做&lt;strong>一個實體的線路&lt;/strong>，一直到 Google 的機房裡面。兩個分別對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Cloud VPN
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS VPN&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure VPN&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Cloud Interconnect
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS Direct Connect&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure ExpressRoute&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>gcloud CLI 概述 II - Authorize the gcloud CLI</title><link>https://aryido.github.io/not-yet-finished/gcp-cli-2/</link><pubDate>Sat, 28 Sep 2024 21:25:48 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/gcp-cli-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們經常會透過 gcloud CLI 和 GCP 的雲端資源互動，為了能夠 Access 到 GCP 的雲端資源，就必須 authorize gcloud CLI，提供了兩個方式來 grant authorization 到 gcloud CLI :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>User account&lt;/strong>: 代表「 End-user 」，是最常見的使用案例也是 best practice&lt;/li>
&lt;li>&lt;strong>Service account&lt;/strong>: 是關聯到 Project 代表「 Application 」而不是「人」的使用者&lt;/li>
&lt;/ul>
&lt;p>無論是 User account 和 Service account ，這兩個都屬於 Google Account 類型並且可以加入到 GCP IAM 成為一個 Principal，授權流程是使用 OAuth2 進行，授權成功之後就會有對應 Access 權限，可用來操作雲端資源了。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Identity and Access Management</title><link>https://aryido.github.io/not-yet-finished/iam/</link><pubDate>Mon, 16 Sep 2024 19:23:44 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/iam/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>GCP - Identity and Access Management 概述</title><link>https://aryido.github.io/posts/google-cloud/iam/</link><pubDate>Mon, 16 Sep 2024 19:23:44 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/iam/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>GCP 雲端資源的權限管理服務是 IAM，其全稱為 Identity and Access Management，可讓管理員(Administrator)去授權(authorize)一個 Identity，使它可以操作特定的 Resources。對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS Identity and Access Managemen&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Microsoft Entra ID (舊稱 Azure Active Directory)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>簡單從英文上來說 IAM 是做什麼的 : 「manage &lt;strong>who&lt;/strong> can do &lt;strong>what&lt;/strong> on &lt;strong>which resources&lt;/strong>」，此概念會貫穿整個 IAM 的使用，用於保護 GCP 資源，提供了非常細粒度的控制，可根據具體需求定制安全性策略。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/google-cloud/iam/iam-overview.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/google-cloud/iam/iam-overview.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Pub/Sub 概述 I - 架構</title><link>https://aryido.github.io/not-yet-finished/pubsub-2/</link><pubDate>Sat, 17 Aug 2024 23:18:06 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/pubsub-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>GCP - Pub/Sub 概述 I - 架構</title><link>https://aryido.github.io/posts/google-cloud/pubsub-1/</link><pubDate>Sat, 17 Aug 2024 23:18:06 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/pubsub-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pub/Sub 是 Google 推出的 Message Service ，作為中介層(Middleware) 可讓系統解耦，解耦的兩系統透過 Publish-Subscribe 的模式來 「異步 asynchronous」 收發消息，實現高可靠(highly reliable) 和高可擴展(scalable)的服務。 簡單以 Event-Driven 消息傳遞設計為主體概念的話，對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>SQS + SNS&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Service Bus Messaging&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Pub/Sub 也簡化了許多 Message Service Infra 的管理如 Broker、Exchange、Queue 等這些底層架構組件並不會直接被使用者接觸，而是 GCP 完全代管且提供 &lt;a href="https://cloud.google.com/pubsub/sla?hl=en">Pub/Sub service level agreement (SLA)&lt;/a>，developer 僅需要瞭解 Message、Topic、Publisher、Subscription、Subscriber 這些接近應用程式端的 Components，算是降低門檻達到快速使用的目的。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP 儲存服務 - 總整理</title><link>https://aryido.github.io/posts/google-cloud/storage-service-all/</link><pubDate>Tue, 13 Aug 2024 23:58:17 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/storage-service-all/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在前面幾個章節有介紹了 GCP 常見的 Storage Service ，有提供了各種高可靠且高可擴展存儲服務產品，雲端化直觀的提供了「減輕管理服務基礎架構」的負擔，特別是是硬體角度的管理。從比較 High-Level 角度來討論的話，雲存儲的服務類型分成&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Block Storage&lt;/strong> : Compute-engine 的 Persistent Disk&lt;/li>
&lt;li>&lt;strong>Object Storage&lt;/strong> : &lt;a href="https://aryido.github.io/posts/google-cloud/cloud-storage/">Cloud Storage&lt;/a>&lt;/li>
&lt;li>&lt;strong>File Storage&lt;/strong> : &lt;a href="https://aryido.github.io/posts/google-cloud/filestore/">Filestore&lt;/a>&lt;/li>
&lt;li>&lt;strong>SQL&lt;/strong> : &lt;a href="https://aryido.github.io/posts/google-cloud/sql/">Cloud SQL&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/spanner/">Cloud Spanner&lt;/a>&lt;/li>
&lt;li>&lt;strong>NoSQL&lt;/strong> : &lt;a href="https://aryido.github.io/posts/google-cloud/firestore/">Firestore&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/bigtable-1/">Bigtable&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/memorystore/">Memorystore&lt;/a>&lt;/li>
&lt;li>&lt;strong>Data Warehouse&lt;/strong> : &lt;a href="https://aryido.github.io/posts/google-cloud/bigquery-1/">Bigquery&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/google-cloud/storage-service-summary/storage-services-new.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/google-cloud/storage-service-summary/storage-services-new.jpg" >
&lt;/a>
&lt;/div>
在現今的雲端計算時代，儲存和管理大量資料變得更加重要，以上這幾種儲存服務需根據業務來選擇，因為這也會決定到訪問和管理組資料的難易程度，故以下對其做一些廣義的整理和筆記來幫助和選擇適合的儲存服務。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Bigquery 概述 II -</title><link>https://aryido.github.io/not-yet-finished/bigquery-2/</link><pubDate>Sun, 11 Aug 2024 02:18:34 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/bigquery-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>BigQuery 除了可以把資料以 columnar storage format 儲存進 BigQuery 內後進行查詢分析，也&lt;strong>支持直接查詢外部資料來源&lt;/strong>如 GCS、Bigtable 、 Spanner/SQL 、 Google Sheets 等等&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Bigquery 概述 I - 架構</title><link>https://aryido.github.io/posts/google-cloud/bigquery-1/</link><pubDate>Fri, 09 Aug 2024 23:08:24 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/bigquery-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>BigQuery 是 Google 提供的一個無伺服器資料倉儲 (Serverless Data Warehouse)，其支持 ANSI SQL 來搜尋資料，所以只要會 SQL 語法就可以立即開始使用，且可高效率分析 TB、PB 等級的資料，故 Bigquery 也是企業級雲端大數據資料分析平台。對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Athena&lt;/strong>、&lt;strong>Redshift Spectrum&lt;/strong>、&lt;strong>Redshift&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Synapse Analytics&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Google 在非常早期的時候，就有類似 BigQuery 其的服務就存在了，是自 2006 年以來一直在內部使用的 Dremel，後來隨著 GCP 雲端平台的產生，並於 2011 年以 BigQuery 為名被正式推出。目前是 GCP 分析資料的主力產品， Google 自家產品如搜尋引擎、 Gmail 等服務背後，其資料處理與分析的核心技術也和 Bigquery 息息相關。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Memorystore 概述</title><link>https://aryido.github.io/posts/google-cloud/memorystore/</link><pubDate>Wed, 07 Aug 2024 16:58:29 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/memorystore/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Memorystore 是 GCP 提供的完全託管 In-Memory Database 服務，可以輕鬆地在 GCP 上建立 Redis 和 Memcached 等著名的開源 &lt;strong>Caching-Engines&lt;/strong>，專門提供&lt;strong>毫秒級的低延遲資料存取/寫入&lt;/strong>，並減輕管理 Database 的部署 deployment、Replica、容錯移轉等等維運事項。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon ElastiCache&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Cache&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Memorystore 也是屬於 NoSQL，由於常用於快取情境故也會被稱呼為&lt;strong>快取資料庫&lt;/strong>。目前看起來主流是使用 Redis，故建議在大部份的使用場景上，優先考慮使用 Redis。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud Spanner 概述</title><link>https://aryido.github.io/posts/google-cloud/spanner/</link><pubDate>Mon, 05 Aug 2024 22:13:08 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/spanner/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Spanner 是 Google 開發的一個完全託管&lt;strong>關係型資料庫&lt;/strong>，屬於企業級 PaaS 解決方案，具有全球同步、全域事務、強一致性、可擴展、分散式和 Replica/Failover 功能，可保證 &lt;code>99.999% &lt;/code>可用性 SLA，使用者不需要多花心思在底層的基礎建設與管理。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon Aurora&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure SQL Database (SQL Server base)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud Spanner 於 &lt;code>2012&lt;/code> 年開始為 Google 內部的重量級產品如 Youtube、Gmail、Google PlayStore 等等提供服務，取代了 Google 的自定義 MySQL 且&lt;a href="https://cloud.google.com/blog/products/databases/inside-cloud-spanner-and-the-cap-theorem">號稱是盡量滿足 CAP 理論限制&lt;/a>。2020Q1 統計每月約 1 億活躍使用者，每天有高達 1800 萬次外送記錄的 Uber，是使用 CLOUD SPANNER 成功案例。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud SQL 概述</title><link>https://aryido.github.io/posts/google-cloud/sql/</link><pubDate>Sat, 03 Aug 2024 23:33:55 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/sql/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud SQL 是 GCP 提供針對 MySQL、PostgreSQL、SQL Server 推出的&lt;strong>完全託管關係型資料庫&lt;/strong>服務，讓使用者能夠從資料庫的管理任務中解放出來，花更多時間在資料本身而非硬體維護。雲端資料庫只是在雲端上建置、部署和存取的資料庫而已，其底層操作和傳統地端資料庫完全一樣，對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon RDS&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure SQL Database for MySQL/PostgreSQL&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud SQL 除了可快速啟用資料庫，還可以同時整合讀寫分離、同步、自動備份、監控等等，也讓我們能更安全便捷地整合 GCP 的其它雲端產品例如：「創建 Table 並從 Cloud Storage 導入 .sql 資料」、「使用 Cloud SQL Auth Proxy 連結到 Compute Engine」、「連接到 BigQuery 來使用聯合查詢」等等。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud SQL 連線</title><link>https://aryido.github.io/not-yet-finished/sql-connection/</link><pubDate>Sat, 03 Aug 2024 23:33:55 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/sql-connection/</guid><description>&lt;!-- raw HTML omitted --></description></item><item><title>GCP - Bigtable 概述 II - 儲存模型</title><link>https://aryido.github.io/posts/google-cloud/bigtable-2/</link><pubDate>Wed, 31 Jul 2024 15:28:33 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/bigtable-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>由於 Bigtable 在 Google 內部廣為使用，故有於 2006 年發表了它的論文介紹：&lt;a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable: A Distributed Storage System for Structured Data&lt;/a>，然後在 2015/5 推出成為 GCP 雲端產品給大眾使用。 在 Google 官網上 Bigtable 的定義是一個 Sparsely-Populated-Table，其中 sparse 意思是如果某 Column 未在特定 Row 中使用，就不會佔用任何空間。&lt;/p>
&lt;p>Bigtable 也可以輕鬆擴展到數十億 Rows 和數千個 Columns ，能夠存儲 PB 級的資料量，適合 High-Throughput 場景的服務，是個強大的服務。而個人也覺得 Bigtable 是對有使用 GCP 的人常被問有沒有使用過的一個雲端服務之一，故可以特別看一下這個服務。(&lt;strong>第一名最常問的，我個人認為是 Bigquery&lt;/strong>)&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Bigtable 概述 I - 架構</title><link>https://aryido.github.io/posts/google-cloud/bigtable-1/</link><pubDate>Tue, 30 Jul 2024 21:58:50 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/bigtable-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Bigtable &lt;strong>並不是&lt;/strong>傳統 RDB 關係型資料庫，而是 GCP 提供的企業級 NoSQL Database，是一個支持大數據應用的&lt;strong>分散式存儲系統&lt;/strong>，保證高可擴展、高可用性、高性能與高吞吐需求的服務，與現有 Apache Big Data 生態系統的開源軟體如 HBase 也有蠻好的整合。對應到其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>DynamoDB&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Cosmos DB&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Bigtable 優勢在於其強大的擴充性，效能完全和 cluster 中的 Node 數量成正比，該產品的強大性完全不用質疑，因為 Google 的很多重量級專案都有使用 Bigtable 來存儲資料例如： Youtube、Google Earth、Google 搜尋引擎、Google Map 等等，每個專案都為數十億活躍使用者提供穩定的服務。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Firestore 概述</title><link>https://aryido.github.io/posts/google-cloud/firestore/</link><pubDate>Sat, 27 Jul 2024 18:02:56 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/firestore/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Firestore 是 Google 提供的一款雲端全代管無伺服器的 &lt;strong>Document NoSQL 資料庫&lt;/strong>，scale out 取向的設計會自動多區域資料複製 replication ，也有強一致性 query 和 transaction 支援。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>DocumentDB&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Cosmos DB&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Firestore 特別的一點是有提供 &lt;strong>realtime listeners 即時監聽器&lt;/strong>來同步 Firestore 資料庫和 client apps 之間的資料，同時也有提供 &lt;strong>offline support 離線支援&lt;/strong>，也就是說一旦雲端的 Firestore 有異動，資料便會自動同步到用戶端上 ; 另一方面當用戶端無法上網時會先存取資料在自己用戶端上，等到可以上網之後會跟雲端的 Firestore 資料庫互相同步。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Filestore 概述</title><link>https://aryido.github.io/posts/google-cloud/filestore/</link><pubDate>Wed, 24 Jul 2024 19:05:55 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/filestore/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Filestore 是 Google Cloud 上完全託管的 Network FileSystem(簡稱 NFS)，目的讓不同的機器甚至是不同的作業系統都可以彼此分享檔案。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Elastic File System (EFS)&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Files&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Filestore 讀寫速度超級快，作為 file storage 並&lt;strong>支持併發同時訪問同一個檔案&lt;/strong>，還提供其他不同種類的存儲類型一些可選替代方案，例如把 Filestore 作為一種「 Persistent Disk 的 block storage 存儲種類 」或者「 類似 Cloud Storage FUSE 的 object storage 存儲種類」等等，因此它適用連接整合到多種 GCP Client 端服務如：VM、GKE、Cloud Run 等等。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud Storage 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-storage/</link><pubDate>Sun, 21 Jul 2024 20:56:57 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-storage/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Storage 簡稱為 GCS ，是 Google 提供的 Object Storage，會把物件儲存在一個名叫 &lt;strong>Bucket&lt;/strong> 的容器內，而 Bucket 還可以有類似劃分資料夾的功能稱 &lt;strong>Managed Folders&lt;/strong>，可以針對這些資料夾加上個別的 IAM 來提供更精細的存取權限。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Simple Storage Service (S3)&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Blob Storage&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud Storage 是具有高性能 BLOB（Binary Large Object）儲存裝置，基本上可當成是&lt;strong>近乎無限大的檔案儲存空間&lt;/strong>，不用預先配置容量也無需花費心力去管理容量，並提供 User 以 Google Web Console 介面 、SDK 或 RESTful API 的方式，簡單直觀地存取儲存的 Object。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP 運算服務 - 總整理</title><link>https://aryido.github.io/posts/google-cloud/compute-service-all/</link><pubDate>Sat, 20 Jul 2024 23:41:17 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/compute-service-all/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面幾個章節有介紹了 Google Cloud 中常見的幾個 Compute Service 運算服務，分別是： &lt;a href="https://aryido.github.io/posts/google-cloud/compute-engine/">Compute Engine&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/cloud-functions/">Cloud Functions&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/cloud-run/">Cloud Run&lt;/a>、&lt;a href="https://aryido.github.io/posts/google-cloud/gke/">Google Kubernetes Engine&lt;/a> :
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/google-cloud/compute-service-summary/compute-services.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/google-cloud/compute-service-summary/compute-services.jpg" >
&lt;/a>
&lt;/div>
這邊也補充介紹 App Engine，它也是屬於 GCP 運算服務，只要上傳滿足&lt;strong>該平台規範&lt;/strong>的 Code 格式就可以開始運作，會自動做負載平衡且並不需要管理任何硬體機器，聽說當年很紅的&lt;a href="https://cloud.google.com/files/Rovio.pdf">遊戲 &lt;strong>Angry Birds&lt;/strong> 就是使用 App Engine&lt;/a> 來作為服務平台。以上這五種運算服務應該在什麼情況下選擇呢？ 選擇正確的基礎架構服務來運行 APP 是很重要的，故以下對其做一些廣義的整理和筆記。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Google Kubernetes Engine 概述</title><link>https://aryido.github.io/posts/google-cloud/gke/</link><pubDate>Mon, 15 Jul 2024 20:06:13 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gke/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Google Kubernetes Engine 簡稱是 GKE ，是一個由 Google 管理的 Kubernetes 開源容器編排平台的實現。因為 Kubernetes 的前身 Borg 本來就是 Google 內部的產品，憑藉著這樣的背景 GKE 號稱對於 Kubernetes 的支援跟擴展性跟其它雲端比起來會是最好的。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>EKS&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>AKS&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>雲端化的 Kubernetes 簡單的說就是&lt;strong>把可在地端原生的 Kubernetes 放到雲端上運行&lt;/strong>，由雲供應商幫助我們大幅簡化集群的設置管理與維運。由於只是讓雲供應商託管 Kubernetes ，最終差異也只是看雲供應商如何「預設」和「整合自己平台其他服務」至 Kubernetes 罷了，本質上 EKS、AKS、GKE 差異並不大，故基本上不推薦隨意更換 Kubernetes 服務的雲供應商或使用多雲，會考慮 GKE 的公司大多都是本來就在使用 GCP 雲端，更方便整合 Kubernetes 和 GCP 的各種服務。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud Run 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-run/</link><pubDate>Sat, 13 Jul 2024 23:14:20 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-run/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Run 是一套基於 Knative 的全代管無伺服器(serverless)容器平台，也屬於 Google Cloud 中的 FaaS 服務，功能是可在 GCP 託管的環境中運行 &lt;strong>Container&lt;/strong> 且已經具有&lt;strong>高擴展性&lt;/strong>基礎架構。若從「無基礎建設的容器化平台（Containers without infrastructure）」的角度來說，對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS App Runner&lt;/strong>、&lt;strong>Fargate&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Container Apps&lt;/strong>、&lt;strong>Azure Container Instances&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud Run 一個蠻大的好處是 : 如果已經把程式打包成 Container Image 鏡象檔，那就可以使用&lt;strong>任何程式語言&lt;/strong>來部署，但其實 &lt;strong>Container Image 化是可選的&lt;/strong>，如果使用的是 Go、Node.js、Python、Java 等等常用的語言，也可以直接使用 Source Code 的方式來部署，讓我們可以使用 FaaS 的概念去執行如 Web Server 比較大型一點的程式。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud Functions 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-functions/</link><pubDate>Fri, 12 Jul 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-functions/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Functions 是一個&lt;strong>無伺服器的雲端執行環境&lt;/strong> (serverless execution environment)，會把寫出來的 code 完全託管給 GCP 並且無需配置任何 Infra 也不用管理任何 Servers 就可以執行了，對於程式設計師來說只需要專注在自己的程式邏輯即可，基本完全省去管理硬體的煩惱，為最標準的 &lt;strong>FaaS&lt;/strong> 類型服務。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS Lamda&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Functions&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud Functions 可以用 Java、Python、Node.js、Go 等常用 coding language 來撰寫，適用於部署單一化用途的程式，或用於連接擴展其他的 GCP 雲端服務，以 Events and triggers 為其核心設計思想。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud NAT 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-nat/</link><pubDate>Tue, 02 Jul 2024 20:18:34 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-nat/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud NAT 全稱是 Cloud Network Address Translation，是 Google Cloud 代管的 IP 轉譯服務，可在不公開 IP 位址的情況下，讓 GCP VM 或 GKE 內的 Pod 可以高效的&lt;strong>連接上&lt;/strong>「外部網路 Internet」，而外部資源無法直接存取 Cloud NAT gateway 後方的資源，維持獨立性與安全性。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>NAT gateways&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure NAT Gateway&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud NAT 是以 Software-defined Networking 服務，中間不存在 proxy instance ，故性能方面比傳統 NAT 好上不少。除了 VM、GKE 之外，也可使用在 Cloud Run、Cloud Functions、App Engine 等服務。&lt;/p>
&lt;/blockquote></description></item><item><title>NAT 概述</title><link>https://aryido.github.io/not-yet-finished/nat/</link><pubDate>Tue, 02 Jul 2024 20:18:34 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/nat/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud NAT 全稱是 Cloud Network Address Translation，是 Google Cloud 代管的 IP 轉譯服務，可在不公開 IP 位址的情況下，讓「某些 GCP 資源」可以高效的&lt;strong>連接上&lt;/strong>「外部網路 Internet」，而外部資源無法直接存取 Cloud NAT gateway 後方的資源，維持獨立性與安全性。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>NAT gateways&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure NAT Gateway&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud NAT 是以 Software-defined Networking 服務，中間不存在 proxy instance ，故性能方面比傳統 NAT 好，目前最經常是用在 VM、GKE 上，除此之外也提供 Cloud Run、Cloud Functions、App Engine 等服務，能夠透過&lt;strong>共用&lt;/strong>一組 IP 位址對外通訊，建立 NAT gateways 連線到 VPC 外部網路，由於&lt;strong>共用&lt;/strong>一組 IP，也解決了 IP 短缺問題。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud DNS 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-dns/</link><pubDate>Mon, 01 Jul 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-dns/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud DNS 是 Google 提供的代管式的全球 Domain Name System(網域名稱系統服務)，為一個&lt;strong>分布式的分層資料庫(hierarchical distributed database)&lt;/strong> 用於存儲 IP addresses 和 Domain Name 的對應關係，還可以建立 DNS Zone 並在其下管理和創建 Record 。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon Route 53&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure DNS&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Cloud DNS 是&lt;strong>提供代管功能而不是註冊&lt;/strong>，而代管的好處是有一個「共同管理維護」的介面 ; 還能「基於地理位置」將流量轉到最接近的服務器從而提高性能與速度 ; 結合「 GCP 雲端安全服務」保護應用程式免於如 DDoS 攻擊。 最後比較特別的是 Google 的 Cloud DNS 服務號稱是 &lt;a href="https://cloud.google.com/dns/sla">100% SLA&lt;/a> 服務保證絕對不會中斷， Google 對其 DNS 服務設計非常的有信心。&lt;/p>
&lt;/blockquote></description></item><item><title/><link>https://aryido.github.io/not-yet-finished/amqp-mqtt/</link><pubDate>Mon, 24 Jun 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/amqp-mqtt/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>DNS 概述</title><link>https://aryido.github.io/not-yet-finished/dns/</link><pubDate>Mon, 24 Jun 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/dns/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>GCP - Cloud CDN 概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-cdn/</link><pubDate>Mon, 24 Jun 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-cdn/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>CDN 全名為 Content Delivery Network，是一種透過分散在不同地區的 server，用離使用者&lt;strong>最近的伺服器&lt;/strong>來傳送快取內容。而 Cloud CDN，就是借助 Google 分佈在&lt;strong>全球各地&lt;/strong>的網路節點，將內容以快取(Cache)形式預先儲存，以達到最快速的內容交付。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon CloudFront&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure CDN&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cloud CDN 會需要與 GCP-Load-Balancer 搭配使用&lt;/strong>，故建議可以先熟習 GCP 負載平衡器的基本用法和觀念。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Cloud Load Balancing 架構概述</title><link>https://aryido.github.io/posts/google-cloud/cloud-load-balancing/</link><pubDate>Mon, 17 Jun 2024 16:54:22 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/cloud-load-balancing/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Load Balancing 是 GCP 透過平均分發流量到多個 server ，以防止單一伺服器的過載從而減少系統故障的風險的產品，對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Elastic Load Balancing&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Load Balancer&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>因為只需透過配置&lt;strong>單個&lt;/strong>對外 IP 地址和憑證，就可讓負載平衡器的內部的管理的所有 VM 被外網存取，故從購買 External IP 的角度來說 Load Balancing 也可算是一種降低維運成本的方式。&lt;/p>
&lt;p>目前從 GCP console 上由&lt;strong>流量類型&lt;/strong>劃分成了「 HTTP(S) 」和 「 TCP/UDP 」兩大類 Load Balancing ，然後在依照細部應用場景還有分成 「Global/Regional」 和 「Internal/External」 等等各種組合，總體設定蠻精細的，可以對應不同的場合需求。&lt;/p>
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/google-cloud/lb/lb-types.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/google-cloud/lb/lb-types.jpg" >
&lt;/a>
&lt;/div>
&lt;/blockquote></description></item><item><title>GCP - Managed instance groups 概述</title><link>https://aryido.github.io/posts/google-cloud/managed-instance-groups/</link><pubDate>Sun, 16 Jun 2024 22:54:22 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/managed-instance-groups/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud 是最能展現&lt;strong>自動伸縮擴展服務&lt;/strong>好處的平台，而 GCP 的 Autoscaling Groups of Instances 代表產品是 Managed Instance Groups (簡稱 MIGs) ，雖然名稱有一點點不太直覺。 GCP 會根據自訂義的 Autoscaling Policy 來自動添加或刪除 VMs ，這些自動縮放而產生的 VMs 會有一個&lt;strong>群組&lt;/strong>來管體，就是 MIG。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Auto Scaling groups&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Virtual Machine Scale Set&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>MIGs 的 Autoscaling Policy 再詳細說一些，是能夠基於 Application 的 CPU/Memory 使用率、網路流量等等設定，自動增加或減少 VM，可根據業務需求或突發流量的場景，靈活調整資源數量從而保證&lt;strong>高性能&lt;/strong>和&lt;strong>成本彈性&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Firewall Rules 概述</title><link>https://aryido.github.io/posts/google-cloud/firewall-rule/</link><pubDate>Mon, 03 Jun 2024 22:59:14 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/firewall-rule/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>通常在我們在 GCP 提到的防火牆，都是指最常用的 &lt;strong>Firewall-Rules 防火牆規則&lt;/strong> ，只能應用在給定的 Project 和指定的 VPC 上，其可以讓資源管理者保護其 VPC 內服務的資料，不會收到未經授權的訪問或者意外流出資料，從而提高安全性和隱私性。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Security Groups&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Network security groups&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>GCP 防火牆其實是一個蠻大的類別，產品全稱是 Cloud Next Generation Firewall 簡稱 Cloud NGFW，而 Firewall-Rules 隸屬於其中的 Cloud NGFW Essentials 。如果想要把 Firewall-Rules 應用到 Organization 下的其他 Project 或者其他 VPC，則要使用 Firewall-Policies，本篇重點介紹 Firewall-Rules。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Network Tag 概述</title><link>https://aryido.github.io/posts/google-cloud/network-tags/</link><pubDate>Mon, 03 Jun 2024 22:59:14 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/network-tags/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Network Tag 在 GCP 中，只是一個簡單的字符串標示並不會建立出雲端資源，&lt;strong>會簡稱為 Tag&lt;/strong> 並可選擇附加到如 VM 或 Instance template 上，其設計想法上是可以由這個標示，更有效地控制和管理 VM 的網路防火牆安全設定。 Network Tag 算是 GCP 比較特別的設計，其他雲端似乎沒有比較類似的對應，由於不是一個獨立的 cloud resource ，所以是無法單獨建立 Tag 的，但對於其關聯的 GCP Firewall Rules ，對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Security Groups&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Network security groups&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>特別要注意的事情是在 GCP 中，Tag 和 Label 是不一樣的東西。通常 GCP 提到 tag 都是指 network tag 這個網路安全相關防火牆設定 ; 而 Label 是拿來作預算及資源管理使用。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - IP addresses 概述</title><link>https://aryido.github.io/posts/google-cloud/ip-address/</link><pubDate>Sun, 02 Jun 2024 14:51:14 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/ip-address/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>GCP IP Address 經常是分配給 GCP VM Instance、GCP Load-Balancer、Cloud NAT 使用，讓他們可以和 GCP 其他雲端資源，或者是外部公共網路上的系統通訊。IP Address 種類劃分也蠻多的，會使用以下種類來描述不同的類型：&lt;/p>
&lt;ul>
&lt;li>Internal IP Address &amp;lt;=&amp;gt; External IP Address&lt;/li>
&lt;li>Private IP Address &amp;lt;=&amp;gt; Public IP Address&lt;/li>
&lt;li>Ephemeral IP Address &amp;lt;=&amp;gt; Static IP Address&lt;/li>
&lt;li>Regional IP Address &amp;lt;=&amp;gt; Global IP Address&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在使用 IP Address 也常發生一些使用上的疏忽，例如一直 reserve IP 卻沒有使用它&lt;/strong>，因為 IP 算是稀有資源，如果有保留固定 IP ，就算沒有使用還是會持續計費的，而且會更貴！&lt;/p>
&lt;/blockquote></description></item><item><title>Cloud NAT 概述</title><link>https://aryido.github.io/not-yet-finished/cloud-nat/</link><pubDate>Thu, 30 May 2024 18:52:24 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/cloud-nat/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>GCP - Virtual Private Cloud 概述</title><link>https://aryido.github.io/posts/google-cloud/vpc/</link><pubDate>Thu, 30 May 2024 18:52:24 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/vpc/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Virtual Private Cloud 虛擬私有雲網路，簡寫為 VPC、網路、VPC Network、Network 等等都可以，是 Google 使用 &lt;a href="https://01.me/2014/03/networking-at-google/">Andromeda&lt;/a>(/ænˈdrɑː.mə.də/) 網路虛擬化技術實現的一個雲端資源，提供如 GCP-VM、GKE、Serverless Workloads 或 App Engine 等等雲端服務的「網路功能」，能讓 User 高自由度的建立管理和優化網路架構。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Amazon VPC&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure Virtual Network&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>GCP-VPC 和 AWS-VPC 架構上蠻不一樣的，GCP-VPC 是全球性的，只要在同一個 GCP-VPC 內，就算不同 Region 也能使用 Internal IP ; 但如果是不同的 GCP-VPC 就算在同一個 Region 下也不能互相通訊。而 AWS-VPC 是針對 Region 來設計的，故 AWS-VPC 只要跨 Region 就不是內網無法直接溝通，需再多做其他設定才能連線到彼此。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Instance Template 概述</title><link>https://aryido.github.io/posts/google-cloud/instance-template/</link><pubDate>Fri, 24 May 2024 19:26:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/instance-template/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Instance Template 是一個用於定義 GCP VM 配置的模板，其中包括如 machine type、bootdisk、startup script 等等 VM 的屬性，經常和 &lt;a href="https://aryido.github.io/posts/google-cloud/managed-instance-groups/">Managed Instance Groups&lt;/a> 結合使用來自動創建 VM 。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>Launch Template&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>沒有直接類似的，在 Virtual Machine Scale Sets 內直接設定 VM 所需參數&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>概念上就是做好 VM 的模板，讓 VM 啟動完成後直接就可以達到我們想要的狀態，從這個方向出發的話 Instance Template 其實和 Startup Script、Custom Image 都蠻類似的，等等都會介紹和比較一下。&lt;/p>
&lt;/blockquote></description></item><item><title>GCP - Compute Engine 概述</title><link>https://aryido.github.io/posts/google-cloud/compute-engine/</link><pubDate>Thu, 23 May 2024 23:26:00 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/compute-engine/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Compute Engine 是託管在 Google 雲端上基礎架構即服務 (IaaS) 產品，其他的稱呼還有 &lt;strong>compute engine instance&lt;/strong> 、 &lt;strong>virtual machine instance&lt;/strong> 、 &lt;strong>VM instance&lt;/strong>。 對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>EC2&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Virtual Machine&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>啟動前可以訂製自己需要的 Machine Type ，例如 CPU、memory、disk 等等；再來 Boot disk OS 也可自行選擇 Linux 、 Windows 等等操作系統；針對容器虛擬化，可能使用專門優化來運行容器的 Container-Optimized OS (COS) image 在虛擬機上啟動容器服務。最後關於&lt;strong>備份資料&lt;/strong>，GCP 也有提供相應的服務來面對災難發生時的處理。&lt;/p>
&lt;/blockquote></description></item><item><title>PaaS、IaaS、SaaS、CaaS 介紹</title><link>https://aryido.github.io/not-yet-finished/iaas-paas-saas-caas/</link><pubDate>Wed, 22 May 2024 23:41:17 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/iaas-paas-saas-caas/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>gcloud CLI 概述 - Auth Credentials</title><link>https://aryido.github.io/posts/google-cloud/gcloud-cli-2/</link><pubDate>Wed, 22 May 2024 22:26:59 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcloud-cli-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>曾經在使用 gcloud CLI 時，有遇到自己錯誤理解的部分，是關於 gcloud 管理的兩組 credentials :&lt;/p>
&lt;ul>
&lt;li>&lt;code>gcloud auth application-default login&lt;/code>: 是用於應用程式的 credential ，此 command 會管理 GCP Client Libraries 等套件會用到的 credential 稱為 Application Default Credentials (簡稱ADC)&lt;/li>
&lt;li>&lt;code>gcloud auth login&lt;/code>: 此 command &lt;strong>只會&lt;/strong>授權 gcloud CLI 工具權限，讓它可以使用 user credential 訪問 GCP 雲端資源，同時把當前的 account activate&lt;/li>
&lt;/ul>
&lt;p>除了以上講解，這兩個還有什麼不同呢 ? 接下來再多做一些探討。&lt;/p>
&lt;/blockquote></description></item><item><title>gcloud CLI 概述 - Initialization GCP Project</title><link>https://aryido.github.io/posts/google-cloud/gcloud-cli-1/</link><pubDate>Wed, 22 May 2024 20:14:37 +0800</pubDate><guid>https://aryido.github.io/posts/google-cloud/gcloud-cli-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>gcloud CLI 全稱是 Google Cloud Command Line Interface ，是創建和管理 GCP 雲端資源的「命令行」
工具，還捆綁了專用的子工具例如 BigQuery(bq CLI)、 Kubernetes 集群(kubectl CLI) 可配合使用，是隸屬在 Cloud SDK 內的。對應其他的雲端服務是 :&lt;/p>
&lt;ul>
&lt;li>Amazon Web Services (AWS) : &lt;strong>AWS CLI&lt;/strong>&lt;/li>
&lt;li>Microsoft Azure : &lt;strong>Azure CLI&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>雖然可以使用 gcloud 來撰寫 script 自動化執行許多常見的任務，但實務上更多是會用例如 &lt;strong>Terraform&lt;/strong> 等 IaC 工具來部屬和管理雲端資源， gcloud 現在基本上用最多是在初始化帳戶如 :&lt;strong>管理身份驗證(manage authentication)&lt;/strong>，或是&lt;strong>自定義本地配置(customize local configuration)&lt;/strong>，這些如權限管理、Project 設定、Billing 有關的功能會是 gcloud CLI 主要使用的地方。&lt;/p>
&lt;/blockquote></description></item><item><title>Language Server Protocol</title><link>https://aryido.github.io/posts/plugin-extension/language-server-protocol/</link><pubDate>Tue, 21 May 2024 23:21:38 +0800</pubDate><guid>https://aryido.github.io/posts/plugin-extension/language-server-protocol/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Language Server Protocol 簡稱 LSP ，是微軟於 2016 製定的 Protocol 協定，專門用來輔助 Visual Studio Code 開發用的，目標是讓 Code-Editor 能便利地支援更多的程式語言。設計理念是把&lt;strong>語言撰寫領域模型如：自動補全、引用定義、類型檢查器&lt;/strong>等等，這些提供輔助功能的部分拆出去用「公定的介面」來做溝通，給各自領域的人開發。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/plugin-extension/lsp-nolsp.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/plugin-extension/lsp-nolsp.jpg" >
&lt;/a>
&lt;/div>
LSP 專門用於描述 Code-Editor 中，用戶行爲與響應之間&lt;strong>通訊方式&lt;/strong>和&lt;strong>傳輸資料結構&lt;/strong>，像是 VSCode 的 IntelliSense 提供的 auto-completion 就可以基於這個協定支援更多不同的 coding language。 現在支援 LSP 的 Code-Editor 也不少，除了 VSCode 還有 Eclipse 、 Vim 、 NeoVim 都已經支援了，可以在 langserver.org 可以看到各個 client 的支援狀況。&lt;/p>
&lt;/blockquote></description></item><item><title>VSCode 基本 layout 介紹</title><link>https://aryido.github.io/posts/plugin-extension/vscode-layout/</link><pubDate>Tue, 21 May 2024 23:21:38 +0800</pubDate><guid>https://aryido.github.io/posts/plugin-extension/vscode-layout/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>「 整合式開發環境 Integrated Development Environment 簡稱為 IDE 」 ，是一種程式開發軟體，通常只針對特定語言，且有應用程式生命週期管理（Application lifecycle management）簡稱 ALM 的功能 ; 另一方面「 文字編輯器 Text Editor 」通常只提供如複製、剪下、貼上、搜尋、取代等&lt;strong>文字操作&lt;/strong>功能，但現在兩者已經沒有區分的這麼明顯了，原因就是 VSCode 的出現很大了融合了兩者。 VSCode 其定位採用核心是 &amp;lt;&lt;strong>Text Editor + code understanding + debug&lt;/strong>&amp;gt;，並以&lt;strong>檔案夾&lt;/strong>作為專案管理，保持輕量與高性能，但還是提供強大的支援語法。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/plugin-extension/vscode-positioning.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/plugin-extension/vscode-positioning.jpg" >
&lt;/a>
&lt;/div>
與許多程式編輯器一樣，VSCode 也採用通用 layout，設計理念是希望可以提供簡單直覺的排版，讓使用者可以直觀的選取檔案並閱覽、編輯檔案，本文章首先討論 Workbench 的定義和介紹 vscode layout 的各個名稱。&lt;/p>
&lt;/blockquote></description></item><item><title>VSCode 架構簡介</title><link>https://aryido.github.io/posts/plugin-extension/vscode-architecture/</link><pubDate>Tue, 21 May 2024 23:21:38 +0800</pubDate><guid>https://aryido.github.io/posts/plugin-extension/vscode-architecture/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Visual Studio Code 簡稱 VSCode ，是微軟 2015 年開源的輕量化 code editor ，基於 Electron 並用自家雲端的編輯器 Monaco Editor 作為其底層開發，支援多語言及平台且使用 TypeScript 來進行編寫，也提供了強大的外掛程式拓展機制給人加強功能。VSCode 的開發是由 Eclipse 之父 Erich Gamma 領導（ Erich 也是《設計模式》作者之一），在 2019 年的 Stack Overflow 開發者研究中，其獲選最受歡迎的 code editor 有 &lt;code>50.7%&lt;/code> 的使用率，且還在持續增加當中。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/plugin-extension/vscode-context-overview.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/plugin-extension/vscode-context-overview.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>Yeoman - 專案模板產生器</title><link>https://aryido.github.io/posts/plugin-extension/yeoman/</link><pubDate>Tue, 21 May 2024 23:21:38 +0800</pubDate><guid>https://aryido.github.io/posts/plugin-extension/yeoman/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>當要建立新專案時，都會需要決定一些關於基礎的架構或開發規劃的事項例如 :&lt;/p>
&lt;ul>
&lt;li>設計 folder structure&lt;/li>
&lt;li>打包編譯工具的選擇&lt;/li>
&lt;li>IDE 預設環境配置；IDE plugin 或 extension 的安裝&lt;/li>
&lt;li>CI/CD、IaC 設定或工具選擇&lt;/li>
&lt;/ul>
&lt;p>每次建立專案時都會參考之前的架構規劃，然後手動複製架構雛形，重新設定參數，其實不太方便&amp;hellip; 這時就可以引入 Scaffold 這樣的&lt;strong>模坂&lt;/strong>概念，來直接生成&lt;strong>專案的骨架&lt;/strong>。本質用意是把那些重複地創建專案基礎結構、專案規格流程取代掉，實現 &lt;strong>DRY (Don’t Repeat Yourself) 原則&lt;/strong>。而 &lt;strong>Yeoman&lt;/strong> 就是一個著名 scaffolding generator tool，微軟官方維護 Visual Studio Code extensions，就是裡面非常著名的例子。&lt;/p>
&lt;/blockquote></description></item><item><title>Homebrew 介紹和常用操作</title><link>https://aryido.github.io/posts/develop/homebrew/</link><pubDate>Mon, 20 May 2024 19:38:28 +0800</pubDate><guid>https://aryido.github.io/posts/develop/homebrew/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Homebrew 是一個廣泛使用在 MAC 上的&lt;strong>套件管理工具&lt;/strong>，可以安裝一些 Mac App Store 上沒有的軟體，其操作十分方便，可以簡化軟體安裝的過程，是個很有名的&lt;strong>非官方工具&lt;/strong>，由 Max Howell 以 Git 和 Ruby 為基底寫成，並通過 GitHub 維護，為 2012 年 GitHub 上擁有最多新貢獻者的專案。對於其作者也有個有趣的軼事：Max Howell 曾應聘過 Google 的職位，面試失敗之後在 Twitter 上發文章 :&lt;/p>
&lt;ul>
&lt;li>Google: 90% of our engineers use the software you wrote (Homebrew), but you can&amp;rsquo;t invert a binary tree on a whiteboard so f*** off.&lt;/li>
&lt;/ul>
&lt;p>因此在網上引發了面試白板題的討論。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - 序列化反序列化詳解</title><link>https://aryido.github.io/posts/data-structure/protobuf-serialization/</link><pubDate>Wed, 01 May 2024 22:10:30 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-serialization/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在越來越多的服務應用使用 Protobuf 來作為資料交換的格式，它被廣泛應用於 RPC 調用和資料存儲。 Protobuf 語言中立、平臺中立，只要定義好一份 &lt;strong>.proto&lt;/strong> 檔案，就可以生成&lt;strong>不同的程式語言&lt;/strong>來處理資料的序列化或反序列化。要了解 Protobuf 序列化/反序列化，首先需要了解一些知識點 :&lt;/p>
&lt;ul>
&lt;li>Varint Encoding&lt;/li>
&lt;li>Zigzag Encoding&lt;/li>
&lt;li>Wire Type 類型&lt;/li>
&lt;li>T-L-V 儲存方式&lt;/li>
&lt;/ul>
&lt;p>熟悉這些可以更加理解 protobuf，也能避免錯誤使用，以及更好的優化性能。本章節會實際把前面學到的知識點一次用上，用實際案例來了解 Protobuf - Serialization。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf - Encoding 結構</title><link>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</link><pubDate>Sun, 28 Apr 2024 17:56:27 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf-encoding-sturcture/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨者網路傳輸、頻寬與硬體的設備的改善和增強，能傳遞資料量也越來越大、越來越複雜，這時我們也不再只是追求能夠將資料傳遞完成，而是更加要求&lt;strong>短時內傳遞大量的資料&lt;/strong>，故勢必會需要強化&lt;strong>序列化&lt;/strong>和&lt;strong>壓縮&lt;/strong>的技術。這篇會介紹 Protobuf 編碼後的 byte array 結構，以及會這樣設計的思路，當有了基本的認識後，就會明白 Protobuf 為何它可以比 JSON、XML 傳輸效率更高，更能壓縮資料，實現高效率。&lt;/p>
&lt;/blockquote></description></item><item><title>Varint &amp; Zigzag Encoding</title><link>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</link><pubDate>Sat, 27 Apr 2024 16:02:33 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/varint-zigzag-encoding/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>蠻多 coding 語言在一般情況下是使用 &lt;code>32 bits&lt;/code> 的空間來儲存整數的，例如 Java 的 int，範圍是 &lt;code>-2147483648 ~ 2147483647&lt;/code>，大約正負21億。但是現實世界中，較小的數字往往比較常出現，大約幾十到幾十萬是最多最常出現的，如果只是要儲存或傳輸這樣的一個小數字，卻每次都需要用到 32 bits 的空間，其實有點浪費，這是有機會優化的 !&lt;/p>
&lt;p>Varint 和 Zigzag 演算法就是要處理這種問題，&lt;strong>讓值小的數字，可以用較少的 byte 數量表示，而達到資料壓縮目的&lt;/strong>，著名的資料傳輸格式 &lt;strong>Protobuf&lt;/strong> 也是通過 Varint 和 Zigzag ，來大幅減少了資料佔用的空間。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf 簡介</title><link>https://aryido.github.io/posts/data-structure/protobuf/</link><pubDate>Fri, 26 Apr 2024 00:44:35 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/protobuf/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Protobuf 全稱 Protocol Buffers ，是一種輕量級的資料交換格式，最初是由 Google 開發的「&lt;strong>可擴展的序列化資料結構&lt;/strong>」，現已成為一個開源項目，其語⾔中⽴且平台無關，適合高性能且對響應速度有高要求的資料傳輸場景；也因為有&lt;strong>資料壓縮&lt;/strong>的能力，故也可用於資料儲存。Protobuf 的核心思想是&lt;strong>先定義好 data schema&lt;/strong> ，然後可根據所需的語言&lt;strong>生成對應的 code base&lt;/strong>，方便使用者操作 :「序列化寫入、反序列化讀取」。&lt;/p>
&lt;p>Profobuf 需要注意的缺點是為&lt;strong>二進制格式&lt;/strong>，故編碼之後不具有可讀性，需要反序列化後才能看得懂資料內容 ; 雖然是個好東西，但並非是個用來完全取代 JSON 的解決方案，JSON 仍有其可讀性高、易操作及通用性高等優點，在多數 API 設計的場景之下，JSON 仍然是最好的選擇。&lt;/p>
&lt;/blockquote></description></item><item><title>Opentelemetry 緣起簡介</title><link>https://aryido.github.io/posts/monitoring/opentelemetry-hisotry/</link><pubDate>Sun, 17 Mar 2024 11:17:16 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/opentelemetry-hisotry/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>OpenTelemetry ，也稱為 OTel，是 Cloud Native Computing Foundation(CNCF) 下的一個開源專案，為一供應商中立(vendor-neutral)的&lt;strong>可觀測性框架&lt;/strong>，目的是提供一個&lt;strong>標準化&lt;/strong>Observability 的 pluggable 框架，解決 telemetry data 的模型定義、檢測、採集、處理、輸出等一致性問題。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/monitoring/opentelemetry-architecture.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/monitoring/opentelemetry-architecture.jpg" >
&lt;/a>
&lt;/div>
借助 OpenTelemetry ，可以從各種來源收集 telemetry data ，但對於資料的存儲和可視化是留給其他工具的，本身並不提供儲存，只能將其發送到其他的服務來存儲，如 Prometheus、或其他雲端廠商服務。&lt;/p>
&lt;/blockquote></description></item><item><title>Regular Expression 簡介</title><link>https://aryido.github.io/posts/develop/regular-expression-intro/</link><pubDate>Fri, 26 Jan 2024 21:19:20 +0800</pubDate><guid>https://aryido.github.io/posts/develop/regular-expression-intro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Regular Expression 是一種強大的&lt;strong>字串匹配&lt;/strong>、&lt;strong>字串查找&lt;/strong>等操作工具，常簡寫爲 regex 、regexp 或 RE。這概念最初由 Unix 的 sed、grep 操作而普及開，它定義一系列&lt;strong>符號&lt;/strong>來描述搜索的規則。
但在不同的 coding language 或者是不同 OS 中， 常發現 regex 都會有些差異，主要原因是演進過程中，出現 &lt;strong>POSIX&lt;/strong> 與 &lt;strong>PCRE&lt;/strong> 兩種 :&lt;/p>
&lt;ul>
&lt;li>
&lt;p>POSIX : 可以說是原初版本，主要用於 UNIX 系統的文本處理，grep 、sed 、awk 等都屬之&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PCRE : 現代 coding language如 Python、Ruby、 C、C++、Java 都屬於 PCRE 派系。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Fluent Bit 基礎介紹</title><link>https://aryido.github.io/posts/monitoring/fluent-bit-intro/</link><pubDate>Wed, 24 Jan 2024 20:40:16 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/fluent-bit-intro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Fluent Bit 是一款使用 C 語言編寫的開源的資料收集器，為 Fluentd 的輕量化版本，也是 Cloud Native Computing Foundation(雲原生運算基金會) 下的一個子項目。可以從&lt;strong>多種不同來源&lt;/strong>【如 Log file、kafka 等等】，收集 Logs、Metrics、 Traces 資料，然後輸出至&lt;strong>多種不同的服務&lt;/strong> 【如 Loki、Fluentd、Elasticsearch、DataDog、Kafka 以及各式雲端服務】。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/monitoring/fluent-bit-2.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/monitoring/fluent-bit-2.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>Elasticsearch 基礎介紹</title><link>https://aryido.github.io/not-yet-finished/elasticsearch-intro/</link><pubDate>Sun, 21 Jan 2024 22:47:34 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/elasticsearch-intro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Elasticsearch 是一款開源的分佈式搜索引擎，也是一個分佈式資料庫。底層是基於 Lucene 開發，另外 ES 來提供了 RESTful API 風格的接口、支持分佈式、可水平擴展。除了進行全文檢索( full-text search )；倒排索引 (Inverted index)，也支持聚合以及排序操作。&lt;/p>
&lt;/blockquote></description></item><item><title>322. Coin Change</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode322/</link><pubDate>Sun, 24 Dec 2023 23:14:10 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode322/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是著名的&lt;strong>零錢兌換&lt;/strong>問題，給我們一些可用的硬幣面額，問&lt;strong>最少&lt;/strong>能用幾個硬幣來兌換出來。標準解法是用 Dynamic Programming 。比較需要知道的地方，是初見時都會想使用 Greedy 方法來做，也就是從最大的 coin 面額拿最多的硬幣開始，如果這個數目無法滿足，那麼從最大的面額數目減一，再重複步驟。但這個解法是錯的 ! 因為&lt;strong>不保證大面額硬幣拿最多的數目就是最佳解&lt;/strong>&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>57. Insert Interval</title><link>https://aryido.github.io/posts/leetcode/leetcode57/</link><pubDate>Sat, 02 Dec 2023 17:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode57/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>此題給定一個沒有 overlapping 且按照起始座標排序的 interval 集合，然後再給一個 newInterval 放到該集合內，要合併 interval 使它們都不會重疊，最後返回新的 &lt;strong>non-overlapping intervals&lt;/strong>。
本題的生活化的模擬，可以把題目想成自修室租借，然後插入自己的使用時段(&lt;del>亂入別人的使用時間&amp;hellip;&lt;/del>)，最後返回整個自修室被租借的時段。&lt;/p>
&lt;/blockquote></description></item><item><title>B Tree</title><link>https://aryido.github.io/not-yet-finished/b-tree/</link><pubDate>Sat, 25 Nov 2023 16:23:31 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/b-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>B-tree 是一種自平衡的樹，能夠保持資料的有序性，能讓搜尋、插入、刪除都在 logN 時間內完成。B-tree 是一個廣義化的 binary search tree，可以擁有多於 2 的 sub-Node。
B-tree 與自平衡 binary search tree 最大不同，是 B-tree 做了讀寫操作做的優化，減少定位記錄時所經歷的中間過程，從而加快存取速度。常應用在 database 和 file-system 實現上。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Pod 實現解析</title><link>https://aryido.github.io/posts/kubernetes/pod-implementation/</link><pubDate>Tue, 07 Nov 2023 23:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/pod-implementation/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pod 是 Kubernetes 中最小的運行單位，它可以包含一個或多個 container。Pod 的實現原理主要涉及以下幾個方面：&lt;/p>
&lt;ul>
&lt;li>容器技術 : 實現隔離和獨立運行&lt;/li>
&lt;li>共享網絡和存儲 : Pod 中的所有容器共享相同的網絡和存儲空間&lt;/li>
&lt;li>Pod 調度 : 調度器會監測節點的資源利用率，將 Pod 調度到適合的節點上運行。&lt;/li>
&lt;li>生命週期管理 : 當 Pod 發生故障或需要擴展時，控制器會自動創建、刪除或調整 Pod 的數量。&lt;/li>
&lt;/ul>
&lt;p>在 Kubernetes 中，Pod 是容器組的概念，爲應用程序提供了一個更加靈活的運行環境，負責管理容器的生命周期和資源。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Secret</title><link>https://aryido.github.io/posts/kubernetes/secret/</link><pubDate>Tue, 31 Oct 2023 21:14:57 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/secret/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Kubernetes Secret 是一種將&lt;strong>配置設置與應用分離的抽象&lt;/strong>，解決服務間配置的冗余與維護問題。主要可以用來保存敏感訊息，將這些 data 放在 Secret 中，比放在 Pod 的定義中或者 Docker Image中，來說更加安全和靈活。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - ConfigMap</title><link>https://aryido.github.io/posts/kubernetes/configmap/</link><pubDate>Mon, 30 Oct 2023 22:42:57 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/configmap/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>ConfigMap 是一種&lt;strong>資源配置管理&lt;/strong>的抽象，可讓不同的微服務間共享配置，提供了一種將&lt;strong>配置設置與應用分離的方法&lt;/strong>，讓我們可以只更新 Config 設定檔 ，而無需修改應用的 Code 或其 Image ，解決服務間配置的冗余與維護問題。基礎的 ConfigMap 用法，通常用於存儲&lt;strong>鍵值對&lt;/strong>，來作爲容器化應用中的&lt;strong>環境變量&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>Reservoir sampling</title><link>https://aryido.github.io/posts/algorithm/reservoir-sampling/</link><pubDate>Sat, 21 Oct 2023 18:33:30 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/reservoir-sampling/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Reservoir sampling 是一個隨機演算法，其目的是在只遍歷一遍的情況下，從大數據 N 的資料流中，隨機選取出 k 個元素，且每筆資料選中的機率都要一樣。這個場景強調了幾件事：&lt;/p>
&lt;ul>
&lt;li>集合 N 很大且不可知，所以&lt;strong>不能一次存入記憶體&lt;/strong>&lt;/li>
&lt;li>時間複雜度為 &lt;code>O(N)&lt;/code>&lt;/li>
&lt;li>隨機選取 k 個數，每個數被選中的機率為&lt;code>k/N&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>本來面對這種問題，比較直接的想法是利用隨機數演算法，求 random(N) 得到隨機數，但是因&lt;strong>資料流極大&lt;/strong>，無法一次都讀到記憶體內，這就表示不能像數組一樣根據 index 獲取元素；而且題目強調&lt;strong>只能遍歷一遍&lt;code>O(N)&lt;/code>&lt;/strong>，代表也不能再採用分塊方式儲存資料，之後再隨機遍歷。為了解決這個問題，可以使用 Reservoir sampling ，非常的巧妙。&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode216</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode216/</link><pubDate>Tue, 17 Oct 2023 23:29:29 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode216/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>90. Subsets II</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode90/</link><pubDate>Tue, 17 Oct 2023 23:01:42 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode90/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 78. Subsets 的進階版，現在數字會有重複(duplicate) 。&lt;/p>
&lt;/blockquote></description></item><item><title>90. Subsets II</title><link>https://aryido.github.io/posts/leetcode/leetcode90/</link><pubDate>Tue, 17 Oct 2023 23:01:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode90/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 78. Subsets 的進階版，現在數字會有重複(duplicate)。這邊使用 Backtrack 模板來求解。這個題目還有要注意的地方，就是 array 不一定是順序的，例如 test case: &lt;code>[4,4,4,1,4]&lt;/code>，這範例在我們去除重複答案的時候，若沒注意到有亂序的可能性，高機率會出錯。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/posts/leetcode/leetcode78/</link><pubDate>Tue, 17 Oct 2023 22:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>很經典的問題 : &lt;strong>冪集 the power set&lt;/strong> ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選排列組合，就可以得出答案。但在程式上要實現卻有一點點難度，故會被歸類到 Medium 等級。這邊使用 Backtrack 模板來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Ingress</title><link>https://aryido.github.io/posts/kubernetes/ingress/</link><pubDate>Thu, 12 Oct 2023 20:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/ingress/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Kubernetes 若要把應用暴露於 &lt;strong>Cluster 外部&lt;/strong> ，已知可以使用 &lt;strong>NodePort&lt;/strong> 和 &lt;strong>LoadBlancer&lt;/strong> 類型的 Service，但當每暴露一個 Service 給外部時，就會需要暴露一個對應的 Port ，隨著 Service 越來越多之後，我們就需要管理更多的 Port Number，也會使得維運上更加複雜。這時就可以考慮使用 Kubernetes Ingress ，它可用來代理不同 Kubernetes Service，能對外開放&lt;strong>統一的 Port&lt;/strong> ，並將外部的請求轉發到 &lt;strong>Cluster 內不同的 Service&lt;/strong> 上，來實現負載均衡。 Ingress 專注於 Cluster 對外的暴露、負載均衡、L7轉發、 Virtual Hosting 等功能。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Service : 應用之間是如何溝通</title><link>https://aryido.github.io/posts/kubernetes/app-communication/</link><pubDate>Thu, 12 Oct 2023 20:09:23 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/app-communication/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubernetes 可以創建多個 Pods，Pod 內有一個或多個 Container，那麼 Container 之間是怎麼溝通的的呢 ? 這裡歸類出一些 case :&lt;/p>
&lt;ul>
&lt;li>不同網路下，不同 pod 間的 container 的通訊&lt;/li>
&lt;li>同一網路下，不同 pod 間的 container 的通訊&lt;/li>
&lt;li>同一個 pod 中，不同的 container 的通訊&lt;/li>
&lt;/ul>
&lt;p>以下來對這些 case 進行說明。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Service : DNS Discovery</title><link>https://aryido.github.io/posts/kubernetes/dns-service-discovery/</link><pubDate>Thu, 12 Oct 2023 20:08:23 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/dns-service-discovery/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Kubernetes 是可以支援 &lt;code>ClusterIP:Port&lt;/code> 、&lt;code>PodIP:Port&lt;/code> 的形式，來完成相互溝通的，但是這樣會帶來些問題，因為 Kubernetes 內部 Pod 和 Service 都有機會重啟的，這會導致 Pod 和 Service 的 IP 發生變化；但 Service 名字等一些標識資訊是不會經常變動的，所以 &lt;strong>Kubernetes 更推薦通過 Service 的名字來訪問服務&lt;/strong>，這就是服務發現。Service Discovery 是一種機制，通過該機制，服務可以動態發現彼此，而無需 hardcode 硬寫 IP 或 endpoint 配置。可以讓我們只透過 Service 的名稱，就能找到相對應 Pod ，而非使用 IP 地址訪問。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Service</title><link>https://aryido.github.io/posts/kubernetes/service/</link><pubDate>Thu, 12 Oct 2023 20:07:23 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/service/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Pod 的生命週期是動態的，因為 cluster 會根據需求，動態地創建或銷毀 Pod ，重啟的 Pod 自然也伴隨着 IP 地址的更動。為了解決這問題，kubernetes 在 客戶端和 Pod 間，引入了一個名為 Service 的組件，它會在 pod 的前方提供了一個穩定的網路端點。&lt;strong>不只可以建立內部 Pod 之間的通信，讓 Pod 間可以用 domain name 的方式相互溝通；另外也可以建立外部與 Pod 的溝通管道&lt;/strong>。 最後 Service 也有能力爲這些 Pod 進行負載分配，平均每個 Pod 的使用率。&lt;/p>
&lt;/blockquote></description></item><item><title>40. Combination Sum II</title><link>https://aryido.github.io/posts/leetcode/leetcode40/</link><pubDate>Tue, 10 Oct 2023 19:15:23 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode40/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 39. Combination Sum 的進階，給定一個 array 和 target ，找出 candidates 中所有可以使數字和為 target 的組合，但 &lt;strong>candidates 中的每個數字，在每個組合中只能使用一次&lt;/strong>。對比 39. 中的數字是可以重複使用，這題是不能重複使用的，但兩題本質沒有區別，依然是使用 DFS 和 backtrack 思想求解。寫到現在其實已經有感覺到一定的模板了，但多多比較與其他 backtrack 題型的差異才是最重要的。&lt;/p>
&lt;/blockquote></description></item><item><title>39. Combination Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode39/</link><pubDate>Tue, 10 Oct 2023 11:46:49 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode39/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了一個 array of &lt;strong>distinct integer&lt;/strong> 以及目標總和 target ，
求用此 array 來組成目標數字的所有組合。像這種要求返回所有符合要求解的題目，基本都是要利用到遞迴，類似的題目有 Subset 、 Permutation 、 Combination 等等，解題套路都是使用 DFS 和 Backtrack 來求得答案。&lt;/p>
&lt;/blockquote></description></item><item><title>Permutations 另解</title><link>https://aryido.github.io/posts/leetcode/leetcode4647/</link><pubDate>Wed, 04 Oct 2023 21:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode4647/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>之前解題利用了&lt;strong>交換 nums 裡面的兩個數字&lt;/strong>的方式，這次換另一種寫法，&lt;strong>做出一個 inner list 收集可能的結果&lt;/strong>。基本解題思想都還是 Backtracking ，故把 leetcode46 和 leetcode47 重新解答一遍。&lt;/p>
&lt;/blockquote></description></item><item><title>47. Permutations II</title><link>https://aryido.github.io/posts/leetcode/leetcode47/</link><pubDate>Wed, 04 Oct 2023 20:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode47/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是經典的 46. Permutations 的進階版，現在數字會有重複(duplicate) 。這邊一樣使用 Backtrack 來求解。從數學上來說，&lt;code>n&lt;/code> 個 element ，且將相同的事物歸為一組, 可歸成 &lt;em>k&lt;/em> 組, 且每組有 &lt;code>m_i&lt;/code> 個，其 Permutation 一共有 &lt;code>n!/(m_1!m_2!...m_k!)&lt;/code> 種排序，為高中數學題中，需要思考下的題目；用程式模擬這個過程也有難度，故被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>46. Permutations</title><link>https://aryido.github.io/posts/leetcode/leetcode46/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode46/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是一道經典 distinct integers 的全排列問題，這邊使用 Backtrack 來求解。從數學上來說，n 個 element 的 Permutation 一共有 n! 種排序，思考起來算蠻簡單的，但要用程式模擬這個推導過程，卻是有點難度的，因此被歸類在 Medium 等級。&lt;/p>
&lt;/blockquote></description></item><item><title>Backtrack 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/backtrack/</link><pubDate>Wed, 04 Oct 2023 20:10:05 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/backtrack/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Backtrack 是 DFS 的一種形式，基本寫法類似於 TOP DOWN DFS，處理方式就是所謂的窮舉法，將所有可能的結果都找出來；每一個結果都實際看看這樣。換個角度來說，其實這個過程就如同在樹上遍歷 (Tree Traversal) ，而普通的 DFS 是不需要回溯狀態的。 Backtrack 強調了狀態回溯。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Workloads &amp; Workload Resources</title><link>https://aryido.github.io/posts/kubernetes/workloads/</link><pubDate>Wed, 04 Oct 2023 00:00:30 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/workloads/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>Workload 是指在 Kubernetes Pod 內運行的應用程式&lt;/strong>。但是 Pod 並不能保證總是可用的，所以需要管理它們。但若直接管理 Pod 的話，工作量將會非常大且繁瑣，為了減輕負擔，Kubernetes 提供 Workload Resources 來管理一組 Pods。即 &lt;strong>Workload Resource 是 Kubernetes 中，定義和管理 Workload 的特定 API 物件&lt;/strong>，例如 Deployment、StatefulSet 等等都是屬於 Workload Resource。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - Deployment</title><link>https://aryido.github.io/posts/kubernetes/deployment/</link><pubDate>Sun, 01 Oct 2023 18:28:05 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/deployment/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Deployment 是 Kubernetes 中，最常使用的的一種工作負載(Workloads)，它以 YAML 格式描述 Pod ，提供聲明式(declarative)的設定。除了定義 Pod 的狀態，更進一步可以管理 :&lt;/p>
&lt;ul>
&lt;li>Pod 的 replica 數量&lt;/li>
&lt;li>升級回滾的策略&lt;/li>
&lt;/ul>
&lt;p>Deployment 是用來&lt;strong>編排無狀態 pod 的一種控制器資源&lt;/strong>，官方也建議應該透過 Deployment 來佈署 Pod &amp;amp; Replicaset，而非直接對 Pod &amp;amp; Replicaset 進行管理。&lt;/p>
&lt;/blockquote></description></item><item><title>Merge Sort</title><link>https://aryido.github.io/posts/algorithm/merge-sort/</link><pubDate>Mon, 04 Sep 2023 21:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/merge-sort/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>歸併排序 (Merge Sort)&lt;/strong> 算是比較優秀的排序算法，因為時間複雜度是 &lt;code>O(N log N)&lt;/code>；而選擇排序、冒泡排序、和插入排序時間複雜度則是&lt;code>O(N^2)&lt;/code>。 Merge Sort 的基本思想是&lt;strong>分治法 (Divide and conquer)&lt;/strong>，是將原問題分解為規模較小的子問題，然後逐一解決這些子問題之後，&lt;strong>合併這些子問題的答案&lt;/strong>，並建立原問題的答案。&lt;/p>
&lt;/blockquote></description></item><item><title>509. Fibonacci Numbers</title><link>https://aryido.github.io/posts/leetcode/leetcode509/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode509/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是非常有名的 Fibonacci 數列，其特徵是除了前兩個數字之外，每個數字等於前兩個數字之和。解法可以帶出一些經典觀念和想法，例如 :&lt;/p>
&lt;ul>
&lt;li>Dynamic Programming&lt;/li>
&lt;li>迭帶 for-loop&lt;/li>
&lt;li>recursion 遞迴&lt;/li>
&lt;/ul>
&lt;p>由於 Fibonacci 數列的時間空間複雜度計算比較特別，加上可以很初步引入很多的思考方式，故雖然這題是 easy ，我還是做個紀錄。&lt;/p>
&lt;/blockquote></description></item><item><title>Recursion</title><link>https://aryido.github.io/posts/algorithm/recursion/</link><pubDate>Mon, 04 Sep 2023 20:03:48 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/recursion/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>遞迴 (Recursion)&lt;/strong>，通過調用自身函數，有時可以將某個複雜的問題，分解為規模較小的子問題。而 Recursion 也經常和以下演算法配合使用 :&lt;/p>
&lt;ul>
&lt;li>分治法 divide and conquer&lt;/li>
&lt;li>回溯法 backtrack&lt;/li>
&lt;li>動態規劃 dynamic programming&lt;/li>
&lt;/ul>
&lt;p>在實際狀況中，遞迴函數的設計常常很難想像，因為遞迴設計屬於&lt;strong>逆向思維&lt;/strong>，在設計遞迴函數的時候，非常容易被這種層層嵌套搞暈，在這裡簡單給個模板範例講解。&lt;/p>
&lt;/blockquote></description></item><item><title>Protobuf &amp; Avro</title><link>https://aryido.github.io/not-yet-finished/protobuf-avro/</link><pubDate>Sat, 02 Sep 2023 20:05:20 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/protobuf-avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在現實情境中，data 的設計總是會不斷變化。故我們都會希望可以變成&lt;strong>能夠快速添加或刪除一些 field&lt;/strong>，但不影響太多系統的設計。目前 Protobuf 和 Avro 都支持 schema reversion，它允許你在不同的時間獨立地更新系統的不同組件，而不用擔心兼容性問題。&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode713</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode713/</link><pubDate>Fri, 01 Sep 2023 00:13:42 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode713/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>Complexity Analysis</title><link>https://aryido.github.io/posts/algorithm/complexity-analysis/</link><pubDate>Wed, 30 Aug 2023 00:06:02 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/complexity-analysis/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在刷 leetcode 時，都會需要分析和解釋一下自己寫的程式的演算法複雜度，基本上主要是解釋 :&lt;/p>
&lt;ul>
&lt;li>時間複雜度&lt;/li>
&lt;li>空間複雜度&lt;/li>
&lt;/ul>
&lt;p>從以上兩個面相去分析 code 效率、品質、trade off，本文記錄一些分析要點。另外建議面試的時候，當對題目有想法時，先不用急著直接實作，而是先估出複雜度，並和面試人討論，確認不會 TLE ；空間是否需要優化；符不符合題目要求等等，最後再開始寫。&lt;/p>
&lt;/blockquote></description></item><item><title>206. Reverse Linked List</title><link>https://aryido.github.io/posts/leetcode/leetcode206/</link><pubDate>Sun, 27 Aug 2023 19:47:15 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode206/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>反轉 Linked List 是一道經典的題目，可以用分別用 :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>指針 (iterative)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>遞迴 (recursive)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>兩種截然不同的風格來解答。個人認為是蠻好的題目，可以多寫幾次，並從各種不同的解答方式來說明思考，故在此筆記。要說簡單也不算，對於 recursive 解法一開始我覺得有點難理解 ! 雖然被歸類在 Easy，但我私心覺得蠻容易打擊第一次做的人的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>234. Palindrome Linked List</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode234/</link><pubDate>Sat, 26 Aug 2023 01:13:14 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode234/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;/blockquote></description></item><item><title>Multiple points 題型簡單介紹</title><link>https://aryido.github.io/posts/algorithm/multiple-points/</link><pubDate>Wed, 23 Aug 2023 22:50:25 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/multiple-points/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Multiple points 的操作，經常用在 array 或 linkedList 上，有幾點事情可以在刷題時特別注意:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>指標會把 list 切成幾個部分，特別注意每一部份的定義&lt;/p>
&lt;/li>
&lt;li>
&lt;p>list 是否有排序或可以排序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指標移動是使用&lt;strong>快慢指標&lt;/strong>還是&lt;strong>左右指標&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>會不會改變原本的 list&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>其中第一點，&lt;strong>把 array 切成幾個部分&lt;/strong>，每個部份的&lt;strong>定義&lt;/strong>，是最重要的思想，可以多思考。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes: Container Network Interface</title><link>https://aryido.github.io/not-yet-finished/network-cni/</link><pubDate>Sun, 25 Jun 2023 21:12:29 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/network-cni/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Container Network Interface（CNI）的基本思想，是先創建好網路命名空間 （netns） ，然後調用外掛程式，替這個網路命名空間配置網路，之後再啟動容器內的進程。 CNI 通過 Json Schema 描述當前容器網路的配置，實現標準化。專注於&lt;/p>
&lt;ul>
&lt;li>創建容器時分配 IP、網段等等&lt;/li>
&lt;li>容器被回收時刪除網路資源&lt;/li>
&lt;/ul>
&lt;p>CNI 作為 Kubernetes 和底層網路之間的一個抽象存在，遮罩了底層網路實現的細節、實現了 Kubernetes 和具體網路實現方案的解耦。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform: Input Variables</title><link>https://aryido.github.io/posts/terraform/variables/</link><pubDate>Tue, 06 Jun 2023 23:21:58 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/variables/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>要讓 Terraform 能有複用性，我們需要加入一些&lt;strong>參數化&lt;/strong>變數來增加彈性，也就是為 module 的 parameter，而且在 root module 中定義好的 variable，可以根據需求來覆蓋。 Terraform Input Variables 的功能，讓我們可以宣告變數，並有幾種方式可以傳入自訂義 variable values:&lt;/p>
&lt;ul>
&lt;li>command line&lt;/li>
&lt;li>&lt;code>.tfvars&lt;/code>&lt;/li>
&lt;li>Environment 讀取&lt;/li>
&lt;/ul>
&lt;p>以下會簡單介紹這些方式和優缺點。&lt;/p>
&lt;/blockquote></description></item><item><title>49. Group Anagrams</title><link>https://aryido.github.io/posts/leetcode/leetcode49/</link><pubDate>Sun, 04 Jun 2023 13:53:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode49/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>所謂的兩字串互為 Anagrams ，意思就是兩個字串中，&lt;strong>字母出現的次數都一樣，只是位置不同&lt;/strong>，比如題目說的 ate 、 eat 、 tea 它們就都互為 Anagrams 。如何判斷兩字串是否互為 Anagrams 是關鍵解題點，這題雖然歸為 Medium ，但是偏向 easy 的，需要注意的點是:&lt;/p>
&lt;ul>
&lt;li>熟悉一些 java 內建常用的字串處理 function ，寫起來會比較簡潔。&lt;/li>
&lt;li>想到使用 map 結構來儲存分組資料。&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>Kubernetes Deployments: Rolling vs Canary vs Blue-Green</title><link>https://aryido.github.io/not-yet-finished/canary/</link><pubDate>Wed, 17 May 2023 00:26:34 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/canary/</guid><description>Canary Deployment 實施流程範例 apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment spec: replicas: 3 selector: matchLabels: app: myapp template: metadata: labels: app: myapp spec: containers: - name: myapp-container image: myapp:v1 ports: - containerPort: 8080 readinessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 5 periodSeconds: 5 livenessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 10 periodSeconds: 10 在範例 yaml 中，使用的 image 是 myapp：v1，其中 replicas 先設 3 個來模擬狀況；比較重要的是要加個 health check 來檢查運行狀況，如果這些探測中的任何一個失敗，Pod 將重新啟動 :
readyinessProbe 檢查容器是否已準備好接收流量 livenessProbe 檢查容器是否仍在運行。 若要執行 Canary Deployment，要創建第二個 deployment yaml 檔，並且使用的 image 是 myapp：v2 新版。然後 :</description></item><item><title>Rolling vs Canary vs Blue-Green</title><link>https://aryido.github.io/posts/cicd/rolling-canary-bluegreen/</link><pubDate>Wed, 17 May 2023 00:26:34 +0800</pubDate><guid>https://aryido.github.io/posts/cicd/rolling-canary-bluegreen/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現今應用程式發展迅速， app 的更新也變得越來越頻繁，在微服務、DevOps、Cloud-native 的迭代過程中，最終都需要上線。上線就需要部署；需要部署就意味著有修改；修改則意味著有風險，要如何在&lt;strong>盡量不影響 user 的前提下，讓 app 升版呢&lt;/strong> ? 這時就有一些&lt;strong>部屬策略&lt;/strong>可以考慮。對於 Deployment Strategies 有一些基本的專有名詞和觀念，例如 :&lt;/p>
&lt;ul>
&lt;li>Recreate&lt;/li>
&lt;li>Rolling&lt;/li>
&lt;li>Blue-Green&lt;/li>
&lt;li>Canary&lt;/li>
&lt;/ul>
&lt;p>對於應該使用哪種 Deployment Strategy 、它們的工作原理、優缺點等等，以下會做些基本介紹。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes: command &amp; arguments</title><link>https://aryido.github.io/posts/kubernetes/command-arguments/</link><pubDate>Sun, 07 May 2023 20:22:59 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/command-arguments/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>當我們在編寫 Kubernetes Pod 相關的 yaml spec 時，有時會針對 spec.containers ，設置啟動時要執行的命令及其參數，而 Kubernetes 提供 &lt;code>command &lt;/code> 和 &lt;code>args&lt;/code>，兩種方式可以選擇。但這時候就會出現一些疑問 :&lt;/p>
&lt;ul>
&lt;li>這兩個差異是甚麼 ?&lt;/li>
&lt;li>Docker Image 中如果自帶 ENTRYPOINT 和 CMD ，若 Kubernetes 再設置 &lt;code>command&lt;/code> 和 &lt;code>args&lt;/code> 會發生甚麼事情呢 ?&lt;/li>
&lt;/ul>
&lt;p>以下就來簡單說明一下。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform: templatefile 範例</title><link>https://aryido.github.io/posts/terraform/templatefile/</link><pubDate>Sun, 23 Apr 2023 17:45:12 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/templatefile/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>templatefile 是 Terraform 的一個&lt;strong>內置函數&lt;/strong>，可讓 Terraform 在運行時，根據變量動態生成文件內容 。 templatefile 函數的基本用法是：&lt;/p>
&lt;ul>
&lt;li>定義一個模板文件，其中包含要插入變量的佔位符。&lt;/li>
&lt;li>在 Terraform code 中，您可以使用 templatefile 函數來讀取模板文件，並提供要插入的變量。&lt;/li>
&lt;/ul>
&lt;p>最後 Terraform 會動態生成文件內容，並將其輸出。&lt;/p>
&lt;/blockquote></description></item><item><title>Avro</title><link>https://aryido.github.io/posts/data-structure/avro/</link><pubDate>Sun, 23 Apr 2023 15:27:54 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Avro 是一個 data serialization 框架 ，是 Apache Hadoop 下的一個子項目，是一個可跨多種程式語言和平台的&lt;strong>傳輸資料格式&lt;/strong>。Avro 可使用 JSON 格式來描述 data structure，並且支持&lt;strong>架構演進&lt;/strong>，保持向後、向前的相容性。
Avro 也提供了編解碼和二進制格式，使得在高吞吐量的應用場景中非常有用且高效。&lt;/p>
&lt;/blockquote></description></item><item><title>Avro 簡介</title><link>https://aryido.github.io/not-yet-finished/avro/</link><pubDate>Sun, 23 Apr 2023 15:27:54 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/avro/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Avro 是一個 data serialization 框架 ，為 Apache Hadoop 下的一個子項目，定義一個可跨多種程式語言和平台的&lt;strong>傳輸資料格式&lt;/strong>。Avro 可使用 JSON 格式來描述 data structure，並且支持&lt;strong>架構演進&lt;/strong>，保持向後/向前的相容性。 Avro 也提供了編解碼和二進制格式，使得在高吞吐量的應用場景中非常有用且高效。&lt;/p>
&lt;/blockquote></description></item><item><title>cloc: code line 統計工具</title><link>https://aryido.github.io/posts/shell-script/cloc/</link><pubDate>Sat, 22 Apr 2023 13:25:32 +0800</pubDate><guid>https://aryido.github.io/posts/shell-script/cloc/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>cloc 全名是 &lt;strong>Count Lines of Code&lt;/strong> ， 為一個計算 code 和設定檔&lt;strong>行數&lt;/strong>的 CLI 工具，是使用 Perl 語言開發的開源統計工具。cloc 支援非常多程式語言、平台、格式的統計，可以快速地計算一個 project 中所有文件的行數、空行、註釋行等等。有時候在寫一些報告會用到，可以幫助整理資料。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform-provider-archive</title><link>https://aryido.github.io/posts/terraform/archive/</link><pubDate>Fri, 21 Apr 2023 22:48:00 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/archive/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>terraform archive 是一個 HashiCorp 公司提供的一個 Provider，可以讓使用者在 Terraform 中，將指定的目錄或檔案打包(例如 zip )。&lt;/p>
&lt;p>雲端上運行的無伺服器計算服務非常熱門，著名的如 AWS Lambda 、 Azure Functions、GCP Cloud Functions，也常使用 terraform 工具來進行部屬。這時再使用 terraform archive ，方便地把例如 python code 打包成 zip，簡便地部署到服務上。&lt;/p>
&lt;/blockquote></description></item><item><title>linux 指令範例: tar &amp; gz</title><link>https://aryido.github.io/posts/shell-script/tar-example/</link><pubDate>Sun, 16 Apr 2023 16:44:04 +0800</pubDate><guid>https://aryido.github.io/posts/shell-script/tar-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>tar是 Unix 和類 Unix 系統上常用的壓縮工具，名字來自於 tape archive 的縮寫， tar 可以將多個文件或目錄打包成一個檔案。單純 .tar 檔案是沒有壓縮資料的，只是把好多目錄與資料夾打包起來變成一個大檔案而已；如果要有壓縮資料的功能，要使用 .tar.gz 壓縮檔案，是最常見的壓縮檔案格式。&lt;/p>
&lt;/blockquote></description></item><item><title>543. Diameter of Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode543/</link><pubDate>Sun, 16 Apr 2023 15:59:57 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode543/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是要求 Binary Tree 的 diameter ，要注意一下 diameter 的定義並&lt;strong>不等於深度&lt;/strong> ! 根據題目中的例子，可了解所謂 diameter 的定義，是兩點之間的最遠距離。雖然 Binary Tree 的 diameter 並不等於深度，但是和深度有非常大的關係，所以解法用 DFS 是比較直觀的想法。(雖然題目難度說是 easy，但我個人覺得應該算初階 medium&amp;hellip;)&lt;/p>
&lt;/blockquote></description></item><item><title>138. Copy List with Random Pointer</title><link>https://aryido.github.io/posts/leetcode/leetcode138/</link><pubDate>Tue, 11 Apr 2023 23:40:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode138/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>deep copy 是程式初新手常會有疑問的地方，這邊剛好可以藉由解題來複習指標的概念。另外這題有很巧妙的解法，就是利用 HashMap 來建立原 node 和拷貝 node 之間的映射 ! 也可以使用遞迴的解法，寫起來相當的簡潔。&lt;/p>
&lt;/blockquote></description></item><item><title>Dockerfile - RUN、CMD、ENTRYPOINT 範例及比較</title><link>https://aryido.github.io/posts/docker/run-cmd-entrypoint-example/</link><pubDate>Sun, 09 Apr 2023 14:44:54 +0800</pubDate><guid>https://aryido.github.io/posts/docker/run-cmd-entrypoint-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>RUN、CMD 和 ENTRYPOINT 指令都可以用來執行具體的命令。RUN 指令是在 Docker &lt;strong>鏡像構建&lt;/strong>時把執行結果會記錄到鏡像中；而 CMD 和 ENTYPOINT 指令是在&lt;strong>容器啟動&lt;/strong>時自動執行。&lt;/p>
&lt;p>ENTRYPOINT 和 CMD 的區別在於使用 ENTRYPOINT 時， CMD 指令會被作為其&lt;strong>默認參數&lt;/strong>，也可以在啟動容器時通過覆蓋 CMD 指令來輸入參數。&lt;/p>
&lt;/blockquote></description></item><item><title>295. Find Median from Data Stream</title><link>https://aryido.github.io/posts/leetcode/leetcode295/</link><pubDate>Sat, 08 Apr 2023 19:56:55 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode295/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題為一個設計題，給了一個 Data Stream，希望設計一個 class 能夠支援連續的 operation，並找出該 Stream 目前的中位數。注意 Data Stream 中的 Data 是無序的且可以為負數，所以我們要做的第一件事是讓&lt;strong>每一次 data 輸入進來，都要讓其有序&lt;/strong>。這裡介紹的解法十分巧妙，&lt;strong>使用 maxHeap 和 minHeap 來解決問題&lt;/strong>，這樣中位數的計算便只要看 maxHeap 的最大值和 minHeap 的最小值來判斷。&lt;/p>
&lt;/blockquote></description></item><item><title>Docker File</title><link>https://aryido.github.io/not-yet-finished/docker-file/</link><pubDate>Sat, 08 Apr 2023 12:50:16 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/docker-file/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dockerfile 是一個設定檔，讓我們可以透過指令的設定，快速地更新或建構 Container 的環境。由於 Dockerfile 中可以清楚的知道映像檔的組成，因此，在安全性上會有所提升，也因為是純文字檔，所以檔案很小、很容易分享。Dockerfile 可以看成是一個腳本，他用來明確告訴 Docker build 指令產生新的 Image 時候，所需的資訊和步驟。Dockerfile 會提供 Docker 引擎建立容器映射所需的指示。這些指令會依序逐一執行。&lt;/p>
&lt;/blockquote></description></item><item><title>Dockerfile - RUN、CMD、ENTRYPOINT 介紹</title><link>https://aryido.github.io/posts/docker/run-cmd-entrypoint/</link><pubDate>Sat, 08 Apr 2023 12:50:16 +0800</pubDate><guid>https://aryido.github.io/posts/docker/run-cmd-entrypoint/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dockerfile 讓我們可以透過設定&lt;strong>指令&lt;/strong>的方式，快速地更新和建構 Image 。由於 Dockerfile 中可以清楚的知道 Image 建構的過程和引用的 package 組成，因此在安全性上會有所提升；也因為是純文字檔，所以 size 很小、易於分享。Dockerfile 裡面有一些指令蠻容易混淆的，這次重點介紹:&lt;/p>
&lt;ul>
&lt;li>RUN&lt;/li>
&lt;li>CMD&lt;/li>
&lt;li>ENTRYPOINT&lt;/li>
&lt;/ul>
&lt;p>這三個指令都可以用來執行具體的命令，&lt;strong>但其中又有些差異&lt;/strong>，以下做一些說明和整理。&lt;/p>
&lt;/blockquote></description></item><item><title>Docker - 基本操作</title><link>https://aryido.github.io/not-yet-finished/docker-cli/</link><pubDate>Thu, 06 Apr 2023 20:53:33 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/docker-cli/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>虛擬化技術 :&lt;/p>
&lt;ul>
&lt;li>系統層級虛擬化（Virtual machine ) ，例如 Virtual Box&lt;/li>
&lt;li>作業系統層級虛擬化（Container），立如 Docker&lt;/li>
&lt;/ul>
&lt;p>Docker 是一個 software platform ，可讓我們快速構建、測試和部署應用程式。Docker 將軟體打包到標準化單元中，這些單元包含軟體運行所需的一切，包括 libraries 、 system tools 、code 等等。Docker 的基本哲學 &lt;strong>Build and Ship any Application Anywhere&lt;/strong> 。&lt;/p>
&lt;/blockquote></description></item><item><title>797. All Paths From Source to Target</title><link>https://aryido.github.io/posts/leetcode/leetcode797/</link><pubDate>Wed, 05 Apr 2023 17:00:37 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode797/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題給了我們一個無環有向圖 (directed acyclic graph)(DAG) 。有 N 個 node ，要找出所有可能的從 &lt;code>node 0&lt;/code> 到 &lt;code>node N-1&lt;/code> 的路徑。像這種需要走到終點，且在每一次新的遞迴時，都要把當前路徑記錄下來，其本質都是&lt;strong>深度遍歷 graph&lt;/strong> ，再加上 &lt;strong>backtrack 回溯狀態&lt;/strong>。是經典的 dfs 的題目。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform : google_firestore_document 範例</title><link>https://aryido.github.io/posts/terraform/firestore-document/</link><pubDate>Tue, 28 Mar 2023 22:22:08 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/firestore-document/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在 Cloud Firestore 中，存儲單位是 document 。document 是一個 lightweight record ，可包含 data 欄位 (稱: fields)，也可以嵌套另一個 collection。
因為 terraform 的 google_firestore_document，要求 fields 的 format 要是 json string ，比想像中的難寫，在這邊簡單紀錄一下範例。&lt;/p>
&lt;/blockquote></description></item><item><title>apt、yum、apk 介绍</title><link>https://aryido.github.io/posts/develop/apt-yum-apk/</link><pubDate>Wed, 22 Mar 2023 22:58:26 +0800</pubDate><guid>https://aryido.github.io/posts/develop/apt-yum-apk/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Linux 有多種流通版本，例如常見的 Ubuntu、Debian、CentOS、Fedora、Red Hat 等等，其中裡面預設的&lt;strong>包管理系統&lt;/strong>也不太一樣。包管理系統可以&lt;strong>安裝 package&lt;/strong> 、&lt;strong>更新 package&lt;/strong> 、確保使用的 &lt;strong>package 是經過審查的&lt;/strong>。 接下來淺淺的分析 apt 、 yum 、 apk 之間的差別。&lt;/p>
&lt;/blockquote></description></item><item><title>Helm 簡介</title><link>https://aryido.github.io/posts/kubernetes/helm/</link><pubDate>Tue, 21 Mar 2023 22:02:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/helm/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Helm 是 kubernetes 的包管理工具。 Helm 有一個公共 Repository ，裏面主要都是配置文件，會把 Kubernetes 服務中各種元件 yaml ，統一打包成一個叫做 Chart 的模組，然後透過 value.yaml，可用來&lt;strong>統一&lt;/strong>管理與設定 Kubernetes ，幫助 developer 和系統管理員，更輕鬆地部署、管理和升級 Kubernetes 中的應用程式。&lt;/p>
&lt;/blockquote></description></item><item><title>79. Word Search</title><link>https://aryido.github.io/posts/leetcode/leetcode79/</link><pubDate>Mon, 20 Mar 2023 22:45:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode79/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給定一個 board 以及 一個 word ，我們要判斷的 board 上是否可以連線出 word。這題是蠻典型的 graph 類題目，用 BFS 或 DFS 解題都行，但用深度優先 DFS 來解題會比較好一些(可以先思考一下為什麼)。解題流程還蠻制式化的，是熟練 graph 類型的練習好題目 XD。&lt;/p>
&lt;/blockquote></description></item><item><title>linux 指令範例: set</title><link>https://aryido.github.io/posts/shell-script/set-example/</link><pubDate>Wed, 15 Mar 2023 22:25:50 +0800</pubDate><guid>https://aryido.github.io/posts/shell-script/set-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>set 是 shell 內建的命令，適當的使用可以增加腳本的安全性和可維護性，幫助腳本執行時可盡快發現錯誤，從而減少不必要的問題。因此很多 &lt;code>script.sh&lt;/code> 檔，第一行都會加&lt;/p>
&lt;ul>
&lt;li>set -euo pipefail&lt;/li>
&lt;/ul>
&lt;p>這篇文章簡單解釋並記錄一下，可以參考使用。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - DaemonSet</title><link>https://aryido.github.io/posts/kubernetes/daemonset/</link><pubDate>Tue, 14 Mar 2023 22:35:58 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/daemonset/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>k8s Cluster 並不直接與 Pod 做互動，而是透過一些管理元件來處理 Pod ，這些管理元件總體被稱為 Workload，這裏介紹 DaemonSet 控制器。DaemonSet 用於提供 Node 基本設施的 Pod，會確保在&lt;strong>所有(或是特定)節點&lt;/strong>上，一定運行著指定的一個 Pod。若想只運行在特定節點運行 DaemonSet Pod，可藉由給定的&lt;strong>標籤&lt;/strong>，讓 Pod 可以只在特定節點上運行。&lt;/p>
&lt;/blockquote></description></item><item><title>76. Minimum Window Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode76/</link><pubDate>Sat, 11 Mar 2023 12:13:17 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode76/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>題目給了我們一個字符 &lt;em>s&lt;/em>，還有一個目標字符 &lt;em>t&lt;/em>，要在 &lt;em>s&lt;/em> 中找到一個 &lt;strong>minimum window substring&lt;/strong> 使得其包含了 &lt;em>t&lt;/em> 中的所有的字母。整體看起來題目難在 :&lt;/p>
&lt;ul>
&lt;li>限制了時間複雜度為 &lt;em>O(n + m)&lt;/em>&lt;/li>
&lt;li>第一次要寫出 bug free 有點困難&lt;/li>
&lt;/ul>
&lt;p>故備標註為 &lt;strong>hard&lt;/strong> ，但整體思路上並不算太難，值得品味一下 !&lt;/p>
&lt;/blockquote></description></item><item><title>linux 指令範例: sed</title><link>https://aryido.github.io/posts/shell-script/sed-example/</link><pubDate>Mon, 06 Mar 2023 22:56:28 +0800</pubDate><guid>https://aryido.github.io/posts/shell-script/sed-example/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;em>sed&lt;/em> 全名為 &lt;em>Stream EDitor&lt;/em> ，取了前面的 &lt;em>S&lt;/em> 和後面的 &lt;em>ED&lt;/em> 來命名。&lt;em>sed&lt;/em> 對正規表示法有良好的支援，主要功能為自動化的修改文字檔，是在 Linux 和 Unix 系統中使用的文本處理工具，可在 pipe 中間進行文字的取代、刪除、插入等等。&lt;/p>
&lt;/blockquote></description></item><item><title>763. Partition Labels</title><link>https://aryido.github.io/posts/leetcode/leetcode763/</link><pubDate>Sun, 05 Mar 2023 22:48:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode763/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題給了一個 string，然後要盡可能將 string 切割越多塊 sub-string 越好( as many parts as possible)，其中條件是&lt;strong>每個 char，最多只能出現在自己的 sub-string 中&lt;/strong>。 即 :&lt;/p>
&lt;ul>
&lt;li>分割字串使字串中的每個字母在該分割段落中出現達到最多次。&lt;/li>
&lt;/ul>
&lt;p>題目理解是和自己想解法是比較花時間的，看過解答後都可以很快寫出來。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes Job 簡介</title><link>https://aryido.github.io/posts/kubernetes/job/</link><pubDate>Thu, 02 Mar 2023 23:10:15 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/job/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>我們知道 kubernetes 的 deployment 可以生成並管理 Pod ，且盡量維持其狀態為 Running 。但有的時候我們會有&lt;strong>只運行一次性任務的需求&lt;/strong>，這時候就可以使用 &lt;a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/">kubernetes Job&lt;/a>。 Kubernetes Job 主要是針對短時和批量的 workload ，用於處理一次性工作，會創建一個或多個 Pod，並在該工作完成後終止這些 Pod，而不是像 deployment、DaemonSets 那樣持續運行。&lt;/p>
&lt;/blockquote></description></item><item><title>18. 4Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode18/</link><pubDate>Wed, 15 Feb 2023 22:17:40 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode18/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Leetcode 幾個數字題，15、16、18，基本上套路都是一樣的(&lt;del>甚至可以預期可能還會出 5 Sum&amp;hellip;&lt;/del>)，整體的解法都差不多，可以一起複習，重點仍然是 :&lt;/p>
&lt;ol>
&lt;li>排序 array&lt;/li>
&lt;li>避免的重複項&lt;/li>
&lt;/ol>
&lt;p>以 3Sum 此基礎上，再加了一個循環而已。&lt;/p>
&lt;/blockquote></description></item><item><title>15. 3Sum</title><link>https://aryido.github.io/posts/leetcode/leetcode15/</link><pubDate>Thu, 09 Feb 2023 22:56:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode15/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>是 Two Sum 的一種另類進階，從 nums 中找出和為 &lt;code>0&lt;/code> 的三個 element ，並組成 &lt;strong>List of list&lt;/strong> 。特別注意，不能有兩個內容一樣的 list。因為整個題目並沒有對 &lt;em>nums&lt;/em> 的 &lt;em>index&lt;/em> 有任何要求，故可以&lt;strong>把 nums 排序&lt;/strong>，為解題拓開另一種思路。&lt;/p>
&lt;/blockquote></description></item><item><title>16. 3Sum Closest</title><link>https://aryido.github.io/posts/leetcode/leetcode16/</link><pubDate>Wed, 08 Feb 2023 21:56:12 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode16/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題跟 15 題相似，又增加了些許難度。題目敘述一樣也很簡單 : 求 nums 內最接近 &lt;em>target&lt;/em> 值的三數和。優化關鍵點一樣是，&lt;em>把 nums 排序&lt;/em>，這樣就可以確定指針滑動方向。
&lt;div class="figure fig-100" >
&lt;a class="fancybox" href="https://aryido.github.io/images/leetcode/16.jpg" data-fancybox="">
&lt;img class="fig-img" src="https://aryido.github.io/images/leetcode/16.jpg" >
&lt;/a>
&lt;/div>
&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - cloud run 出現錯誤</title><link>https://aryido.github.io/posts/develop/m1-error-2/</link><pubDate>Sun, 08 Jan 2023 21:54:38 +0800</pubDate><guid>https://aryido.github.io/posts/develop/m1-error-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Cloud Run 是 Google 的 Serverless 產品，讓我們不用管理基礎 infra 也能建置容器，並會根據流量自動調整資源，且只依據實際使用的資源收費。 這邊特別注意一下，目前 Cloud Run 似乎還沒支持 ARM 格式的 image，故有使用 M1 筆電包 docker image 要特別注意一下，這會出現不可預期的 bug !&lt;/p>
&lt;/blockquote></description></item><item><title>Apple M1 作業系統坑 - CPU 簡介</title><link>https://aryido.github.io/posts/develop/m1-error-1/</link><pubDate>Wed, 04 Jan 2023 23:02:30 +0800</pubDate><guid>https://aryido.github.io/posts/develop/m1-error-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>現在公司很多都會給新進員工配上 Apple M1 筆電，整體筆電用起來都還不錯的。但因為 Apple M1 底層處理器架構大改變，對於軟體開發在本地端測試時候，常發生一些不可預期的狀況。這邊就來記錄一下有遇到的 BUG。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes - kubectl 簡單筆記</title><link>https://aryido.github.io/posts/kubernetes/kubectl/</link><pubDate>Sun, 25 Dec 2022 21:38:20 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/kubectl/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>kubectl 是針對 k8s cluster 的 API Server 發送命令的工具，有些指令會改變 K8s cluster 的 state 和任何對應到的環境變量。默認情況下，kubectl 在 &lt;strong>$HOME/.kube&lt;/strong> 目錄下查找名為 config 的文件，kubectl 使用該 config 文件來查找要通訊的 K8s cluster 資料。&lt;/p>
&lt;/blockquote></description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://aryido.github.io/posts/leetcode/leetcode26/</link><pubDate>Sun, 25 Dec 2022 15:05:58 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode26/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這道題要我們從&lt;strong>有序數組&lt;/strong>中去除重複項，題目難度雖然被歸為 easy 等級，但在&lt;strong>條件限制&lt;/strong>上的討論，蠻多東西可以釐清討論的。 英文方面寫得蠻長，記得要看到最後因為有寫一些限制如 :&lt;/p>
&lt;ul>
&lt;li>&lt;em>O(1)&lt;/em> extra memory&lt;/li>
&lt;li>The relative order of the elements should be kept the same.&lt;/li>
&lt;/ul>
&lt;p>所以&lt;strong>不能用 Set 或另開 array 去寫&lt;/strong>。另外也花了些篇幅去說明，只要原 array 前面長度部分內，有把所有不重複數字列出來就好，不需要在意後面 array 的元素和 array 的長度。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 2</title><link>https://aryido.github.io/posts/kubernetes/overview-2/</link><pubDate>Sat, 24 Dec 2022 12:30:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>在上一篇文章中，簡單介紹了 Kubernetes 的架構，接下來簡介 Kubernetes 在部屬 app 時的單位 Pod 。 Pod 對多容器的支持是 K8 最基礎的設計理念，但 Pod 應該怎麼被管理呢 ? 怎麼和外網連線呢 ? 這些部分由如下元件提供功能解決 :&lt;/p>
&lt;ul>
&lt;li>Deployment&lt;/li>
&lt;li>Service&lt;/li>
&lt;li>Ingress&lt;/li>
&lt;/ul>
&lt;p>像在實現進階的操作如:負載均衡、滾動更新、安全與監控等概念，都會跟這些元件有關係。&lt;/p>
&lt;/blockquote></description></item><item><title>Kubernetes 基礎介紹 - 1</title><link>https://aryido.github.io/posts/kubernetes/overview-1/</link><pubDate>Mon, 19 Dec 2022 23:38:06 +0800</pubDate><guid>https://aryido.github.io/posts/kubernetes/overview-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>從第一次聽到 Kubernetes 以來，已經有一年多了，永遠都記得 k8s 名稱的由來只是保留「開頭 K」及「結尾 S」，然後中間的英文字母數量剛好是 8 個英文字就這樣命名了&amp;hellip;。全球三大雲服務商，AWS、Azure 和 GCP 都有提供託管 Kubernetes 集群服務( EKS、AKS、GKE )，可見其有名火熱程度。現在終於有機會在工作上碰到這項技術，就來寫些簡單筆記吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode83</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode83/</link><pubDate>Sun, 18 Dec 2022 21:50:23 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode83/</guid><description>&lt;!-- raw HTML omitted --></description></item><item><title>AWS EKS</title><link>https://aryido.github.io/posts/aws/eks/</link><pubDate>Sat, 17 Dec 2022 18:45:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/eks/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>ECS 很常拿來與 Kubernetes 比較，而 2017 aws 又進一步宣佈了 Amazon Elastic Container Service for Kubernetes(EKS)，使 aws 平台可以託管 k8s 服務。EKS 服務可以省去安裝以及操作自己的 Kubernetes 叢集的時間，輕鬆的在 AWS 上執行 Kubernetes；進一步地，可使用 Fargate 模式在 &lt;em>EKS&lt;/em> 上，可連 node 機器都不用管理。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS ECS</title><link>https://aryido.github.io/posts/aws/ecs/</link><pubDate>Sat, 17 Dec 2022 16:30:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/ecs/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Amazon Elastic Container Service（ECS）標誌著 AWS 進入 CaaS 市場。在 Kubernetes 還沒有出現時，各家雲端大廠對於&lt;strong>容器化的管理工具&lt;/strong>都有自己實作。對應在 AWS 上的容器編排平台，是在 2014 年宣佈的 ECS 服務。後續進一步改進，發布 ECS with Fargate，可讓我們運行 container，而&lt;strong>無需管理伺服器或集群&lt;/strong>。 故 Amazon ECS 具有兩個常用模式：&lt;/p>
&lt;ul>
&lt;li>EC2 啟動類型&lt;/li>
&lt;li>Fargate 啟動類型&lt;/li>
&lt;/ul>
&lt;p>以下分別進行介紹。&lt;/p>
&lt;/blockquote></description></item><item><title>Overview Fargate</title><link>https://aryido.github.io/posts/aws/fargate/</link><pubDate>Sat, 17 Dec 2022 16:30:30 +0800</pubDate><guid>https://aryido.github.io/posts/aws/fargate/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>2017年，AWS 推出了 Fargate，這是一個用於部署和管理容器的&lt;strong>模式&lt;/strong>，代表用戶無需管理 EC2 基礎設施。 Fargate 的核心理念就是 &lt;strong>Serverless&lt;/strong> ，讓 ECS 用戶專注於任務和服務定義，而不是管理集群基礎設施，Fargate 可配合用於 &lt;em>ECS&lt;/em> 和 &lt;em>EKS&lt;/em>。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS Overview: ECS | EKS</title><link>https://aryido.github.io/posts/aws/aws-ecs-eks/</link><pubDate>Tue, 13 Dec 2022 21:28:20 +0800</pubDate><guid>https://aryido.github.io/posts/aws/aws-ecs-eks/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>ECS (Elastic Container Service) 和 EKS（Elastic Kubernetes Service）都是 AWS 上提供的 Container Orchestration ( 容器管理工具 )，核心都是&lt;strong>中央控制管理&lt;/strong>運行的容器化應用程式，以下來簡單介紹一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - binary search</title><link>https://aryido.github.io/posts/leetcode/leetcode410-2/</link><pubDate>Sun, 11 Dec 2022 18:32:09 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹用 dp 方式把這題給解了，但看一下 Related Topics 發現也可以用 Binary Search 求解，上網參考大神們的解法，感覺特別巧妙。因為這題可用 dp 和 Binary Search，也變成是一道高頻難題。
這邊記錄一下大神們的想法。&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform Move</title><link>https://aryido.github.io/posts/terraform/terraform-move/</link><pubDate>Sun, 04 Dec 2022 19:31:26 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terraform-move/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>隨著系統的擴充， Terraform 配置也會變得越來越複雜，這時可能會需要做一些 Refactor，例如 :&lt;/p>
&lt;ul>
&lt;li>將某些 terraform resource 移動到其他 module&lt;/li>
&lt;li>change resource ID&lt;/li>
&lt;/ul>
&lt;p>這時候用 terraform plan 檢查一下，會發現 terraform 打算把原本的 resource 移除，然後重新建立一個新的 resource。但 resource 中間被刪掉，之後再造回來是會影響服務的。我們必須讓 Terraform 知道我只是重新命名，這就是 Terraform move 想做的事情。&lt;/p>
&lt;/blockquote></description></item><item><title>cloud init 簡介</title><link>https://aryido.github.io/posts/cloud/cloud-init/</link><pubDate>Tue, 29 Nov 2022 20:23:44 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/cloud-init/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>cloud-init 是一個 package，可以藉由配置 cloud-init 來執行各種任務，自動初始化 cloud instance。在初次開機時就將想要的檔案或設定與系統一併弄好而不用手動處理。大部分雲平台都支持 cloud-init，目前是 &lt;strong>industry standard (行業標準)&lt;/strong>。&lt;/p>
&lt;/blockquote></description></item><item><title>Packer build machine image 偶爾會出錯誤</title><link>https://aryido.github.io/posts/cloud/packer-build-image-error/</link><pubDate>Mon, 28 Nov 2022 22:04:39 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/packer-build-image-error/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>使用 Packer 建立 AWS EC2 AMI 或者是 GCP Machine Image，兩個都會有機率發生一些問題， 有時候是 image 內一些應用程式安裝出現問題；有時候是再最後啟動 AWS 或 GCP 虛擬機時，使用 user-data 或 startup-script 時會出現問題，共同的錯誤訊息是 &lt;strong>no installation candidate.&lt;/strong> 。 AWS 機率發生體感機率比 GCP 高不少。那問題的根源是什麼呢，來看看吧!&lt;/p>
&lt;/blockquote></description></item><item><title>410. Split Array Largest Sum - dynamic programming</title><link>https://aryido.github.io/posts/leetcode/leetcode410/</link><pubDate>Sun, 27 Nov 2022 20:26:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode410/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題真的蠻難的，一開始看題目我也覺得很繞口，給了一個非負數的 nums 和一個 m 代表把 nums 分成 m 個 group 且 每個 group non-empty 並取 m 個 group 中的最大值。但注意，前面只是代表一種&lt;strong>切法&lt;/strong>而已，我們是要找所有可能&lt;strong>切法&lt;/strong>之中的最小值。看一下 Related Topics 發現可以用 Binary Search 和 DP 求解，也是一道高頻題目。&lt;/p>
&lt;/blockquote></description></item><item><title>877. Stone Game</title><link>https://aryido.github.io/posts/leetcode/leetcode877/</link><pubDate>Fri, 25 Nov 2022 23:36:44 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode877/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>石頭遊戲，兩個人輪流選石頭，Alex 先選，每次只能選開頭或結尾，最終獲得石頭總數多的人獲勝。 乍看之下不好想到可以用 DP 解，但其實可用一個 2D-state 去描述遞迴的狀態。 這題一開始會好奇是因為負評倒讚很多，個人是感覺能從 Game Theory 單純想出這結論也是蠻厲害的&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terraform 實用技巧</title><link>https://aryido.github.io/posts/terraform/terraform-skill/</link><pubDate>Thu, 24 Nov 2022 23:07:42 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terraform-skill/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>最近很常寫 Terraform ，知道一些 terraform cli 指令可以幫助自己寫的更好，也在學習 Terraform 的過程中，把覺得值得記錄的一些注意事項 &amp;amp; 小技巧留在這裡。&lt;/p>
&lt;/blockquote></description></item><item><title>1143. Longest Common Subsequence</title><link>https://aryido.github.io/posts/leetcode/leetcode1143/</link><pubDate>Tue, 22 Nov 2022 22:46:42 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1143/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是求最長相同的&lt;strong>子序列&lt;/strong>，可用 Dynamic Programing 來做，最難的還是想出狀態函數。這裡使用 2D-dp ，其中 dp[i][j] 表示 :&lt;/p>
&lt;ul>
&lt;li>text1 的前 i 個字符&lt;/li>
&lt;li>text2 的前 j 個字符&lt;/li>
&lt;/ul>
&lt;p>的最長相同的子序列的字符個數&lt;/p>
&lt;/blockquote></description></item><item><title>Java 賦值語句的返回值</title><link>https://aryido.github.io/posts/java/java-assignment-statement/</link><pubDate>Sun, 13 Nov 2022 23:32:56 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-assignment-statement/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java 賦值語句，是有返回值的，而且還並不是想像中的 bool 類型 ！ 想想其實一直都有看到一些類似的用法，但因自己平時開發並沒有特別使用過，也沒有很深入去探討了解。今天在這邊就舉例一些出來，來說明 Java 賦值語句的返回值。&lt;/p>
&lt;/blockquote></description></item><item><title>CIDR 介紹</title><link>https://aryido.github.io/posts/develop/cidr/</link><pubDate>Sun, 13 Nov 2022 17:37:27 +0800</pubDate><guid>https://aryido.github.io/posts/develop/cidr/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>無類別域間路由（ Classless Inter-Domain Routing ，簡稱 CIDR ）是為了避免造成 IP 位址的大量浪費，於是出現的一種技術。CIDR重點有：&lt;/p>
&lt;ol>
&lt;li>多變長度子網路遮罩 (Variable-Length Subnet Mask，VLSM)&lt;/li>
&lt;li>路由匯總 （Route Summarization）(暫不介紹)&lt;/li>
&lt;/ol>
&lt;/blockquote></description></item><item><title>63. Unique Paths II</title><link>https://aryido.github.io/posts/leetcode/leetcode63/</link><pubDate>Sun, 13 Nov 2022 15:22:47 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode63/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是 62. Unique Paths 的延伸，能選擇往下或往右走直至終點為止，要求出有多少種可能走法，但多了一個限制，會在路徑中加了一些 obstacle 擋住了某些路徑。是一道典型的 Dynamic Programming - 2D matrix 類型的題目。和爬樓梯等都屬於動態規劃中常見題目，因此也經常會被用於面試之中。&lt;/p>
&lt;/blockquote></description></item><item><title>139. Word Break</title><link>https://aryido.github.io/posts/leetcode/leetcode139/</link><pubDate>Sat, 12 Nov 2022 22:10:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode139/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>一道很經典的題目，是給定一 string ，能不能分被拆分成 wordDict 裡面的單詞。注意這題，wordDict 裡面的單詞可以重複使用，即單詞使用沒有次數限制，所以 string 可以分成任意段，這就增加了題目的難度。解法蠻多種的，可先從 brute force 下手，再加上暫存優化後，就是蠻標準的 dp 解了，來解一下吧。&lt;/p>
&lt;/blockquote></description></item><item><title>IP and Subnet Mask 介紹</title><link>https://aryido.github.io/posts/develop/ip-and-subnetmask/</link><pubDate>Mon, 07 Nov 2022 22:55:14 +0800</pubDate><guid>https://aryido.github.io/posts/develop/ip-and-subnetmask/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>IP (Internet Protocol) 是電腦的地址。IP 位址在系統中是一個 32 位元的數字，但為了方便人類讀寫，每一個位元組會被轉換成一個十進位的數字。&lt;/p>
&lt;p>IP 位址可以分為 Network ID 和 Host ID，為了讓電腦可以判斷出 IP 位址的 Network ID 及 Host ID，必須靠子網路遮罩 (Subnet Mask) 的幫忙。&lt;/p>
&lt;/blockquote></description></item><item><title>78. Subsets</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode78/</link><pubDate>Sun, 06 Nov 2022 22:54:12 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode78/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題是很經典的問題: &lt;strong>冪集 power set&lt;/strong> ，在數學上還蠻常見到的，理論上求得解答方式也很簡單，選或者不選就可以得出。但在程式上卻有點點難度，會被歸類到 Medium 等級。這邊使用 backtrack 模板來解題，但其實也有非遞回式的解法，都可看看並練習。&lt;/p>
&lt;/blockquote></description></item><item><title>Dynamic Programming 基礎介紹</title><link>https://aryido.github.io/posts/algorithm/dynamic-programming1/</link><pubDate>Wed, 02 Nov 2022 21:52:00 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/dynamic-programming1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Dynamic Programming 大概算是 leetcode 裡面平均難度最高的章節了，還蠻需要練習的。但在講 DP 之前，我們可以先講 Search，因為 Dynamic Programming 其實就是 Search + Memoization。&lt;/p>
&lt;/blockquote></description></item><item><title>Datadog V.S Grafana</title><link>https://aryido.github.io/posts/monitoring/datadog/</link><pubDate>Mon, 31 Oct 2022 23:35:14 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/datadog/</guid><description>&lt;blockquote>
&lt;p>Datadog 是 2010 年成立，以 infrastructure monitoring 起家。主要是整合多個雲平台如 GCP, AWS, Azure，讓工程師方便監測以進行 debug 。另外可用機器學習方式，將預先對可能發生異常狀況發出警示，是企業級的解決方案。&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode102</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode102/</link><pubDate>Sun, 30 Oct 2022 19:54:09 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode102/</guid><description>&lt;!-- raw HTML omitted --></description></item><item><title>Terraform - GCP Load Balancer Module</title><link>https://aryido.github.io/posts/terraform/gcp-aws-terraform-module/</link><pubDate>Sat, 29 Oct 2022 23:17:25 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/gcp-aws-terraform-module/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>目前使用 AWS 和 GCP terraform module 的感想，其實我覺得都還可以。但這邊特別覺得 GCP load-balancer module，我個人感覺寫得真的不好，有很多地方應該可以寫得更好，讓使用者體驗更棒的，但他們並沒做到&amp;hellip;，也讓我思考了其實一昧 module 化是否有必要呢 ? 讓我列出來一些我簡單比較和缺點吧。&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode130</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode130/</link><pubDate>Sun, 23 Oct 2022 14:27:33 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode130/</guid><description>&lt;!-- raw HTML omitted --></description></item><item><title>560. Subarray Sum Equals K</title><link>https://aryido.github.io/posts/leetcode/leetcode560/</link><pubDate>Sun, 23 Oct 2022 11:03:19 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode560/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題我看起來也是很技巧性的題目，一開始要把 subarray 的特性掌握的淋漓盡致，並且想到用 hashmap 來建立快速查找關係，真的有點困難&amp;hellip;但也是這道題的魅力吧 ! 基本上 hashmap 題目大概都會偏向這種步驟應用，多注意可以讓自己視野開闊。&lt;/p></description></item><item><title>AWS load-balancer 基礎介紹</title><link>https://aryido.github.io/posts/aws/aws-load-balancer/</link><pubDate>Mon, 17 Oct 2022 22:00:06 +0800</pubDate><guid>https://aryido.github.io/posts/aws/aws-load-balancer/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>AWS 目前有多種 Load Balancing&lt;/p>
&lt;ul>
&lt;li>Application Load Balancer&lt;/li>
&lt;li>Network Load Balancer&lt;/li>
&lt;li>Classic Load Balancer&lt;/li>
&lt;/ul>
&lt;p>對於 Classic Load Balancer ，除非還有 ec2 運行在 ec2-classic 網路的場景，要不然已經&lt;strong>不建議&lt;/strong>使用了，建議使用 Application Load Balancer 、 Network Load Balancer 取代。&lt;/p>
&lt;/blockquote></description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://aryido.github.io/posts/leetcode/leetcode1011/</link><pubDate>Sat, 15 Oct 2022 19:18:43 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode1011/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>這題是 Google 面試題，在 Hide Hint 中表示可以使用 binary-search 解決，剛開始覺得蠻 tricky 的，但仔細思考會覺得 binary-search 很符合這題目。&lt;/p></description></item><item><title>Binary Search - 2 各式模板</title><link>https://aryido.github.io/posts/algorithm/binary-search2/</link><pubDate>Sat, 15 Oct 2022 17:47:39 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前面有介紹了 Binary Search 的通用模板，但通用模板還是有缺點，就是要找的目標須在 array 範圍內，這樣才能定義 index。但很多時候題目並不會有一個準確的 array 被定義，還是需要了解各個模板才能比較好的去解答各式題目。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search - 1 觀念介紹</title><link>https://aryido.github.io/posts/algorithm/binary-search1/</link><pubDate>Sat, 15 Oct 2022 16:27:29 +0800</pubDate><guid>https://aryido.github.io/posts/algorithm/binary-search1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Binary-Search (二分搜尋法)，是一種針對&lt;strong>已經排好序&lt;/strong>的區間內， &lt;strong>O(logN)&lt;/strong> 的搜索方式。
Binary-Search 在處理邊界時很容易出錯。 基本上都是沒注意到兩大原則 :&lt;/p>
&lt;ul>
&lt;li>每次都一定要縮減收所區域&lt;/li>
&lt;li>每次縮減不能排除潛在答案&lt;/li>
&lt;/ul>
&lt;p>雖然淺顯易見，但實踐在寫的時候還是常常會寫出 bug 。&lt;/p>
&lt;/blockquote></description></item><item><title>Leetcode819</title><link>https://aryido.github.io/not-yet-finished/leetcode/leetcode819/</link><pubDate>Mon, 10 Oct 2022 15:31:46 +0800</pubDate><guid>https://aryido.github.io/not-yet-finished/leetcode/leetcode819/</guid><description>&lt;!-- raw HTML omitted --></description></item><item><title>127. Word Ladder</title><link>https://aryido.github.io/posts/leetcode/leetcode127/</link><pubDate>Sun, 09 Oct 2022 23:23:53 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode127/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題第一眼其實看不太出來是 graph 題，但仔細分析會發現是一個單詞，然後能 reach 到的是換一個字母的單詞，就是鄰居；然後要找最短路徑。 難就是難在一開始要把問題轉化成一個 graph!&lt;/p>
&lt;/blockquote></description></item><item><title>GCP Filestore vs AWS EFS 收費標準</title><link>https://aryido.github.io/posts/cloud/filestore-vs-efs/</link><pubDate>Fri, 07 Oct 2022 22:03:14 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/filestore-vs-efs/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>雲端資源在使用的時候，可以特別注意收費的部分。 例如 GCP Filestore 和 AWS EFS 都是有關於 file share 的功能，但計費方式卻很不一樣。養成沒事看看雲端 billing 可以幫助止血&amp;hellip;，踩完坑之後就來看看付費公式吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - 整理</title><link>https://aryido.github.io/posts/terraform/terragrunt-5/</link><pubDate>Thu, 06 Oct 2022 22:31:20 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>基本上 terragrunt 的使用和 terraform 都一樣，所以才說 terragrunt 是一層 wrapper。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>terragrunt init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>terragrunt plan
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>terragrunt apply
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>和 terraform 都一樣對吧 !&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - variables 精簡</title><link>https://aryido.github.io/posts/terraform/terragrunt-4/</link><pubDate>Wed, 05 Oct 2022 23:27:20 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-4/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>變數管理也是一個讓 code 更加 DRY 的方式之一， terragrunt 有蠻多傳遞變數的方式，這邊舉例 inputs&lt;/p>
&lt;/blockquote></description></item><item><title>AWS 與 GCP reliability 不同的地方比較 - 2</title><link>https://aryido.github.io/posts/cloud/reliability2/</link><pubDate>Tue, 04 Oct 2022 22:23:28 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/reliability2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>前段時間社群上有人 po 出 GCP 和 AWS 的比較，然後測出 GCP 慘烈的 VM 生成時間和一堆 409 錯誤，聽說有驚動 Google 高層(&lt;del>怕.jpg&lt;/del>)。那現在我們來針對該作者開源的測試程式來看看吧!&lt;/p>
&lt;/blockquote></description></item><item><title>23. Merge k Sorted Lists</title><link>https://aryido.github.io/posts/leetcode/leetcode23/</link><pubDate>Mon, 03 Oct 2022 21:54:34 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode23/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題需求是要合併 k 個 linked-list 成一個大的 linked-list，&lt;strong>每個 linked-list 都是有序的&lt;/strong>，且大的 linked-list 也必須是有序的，是 LeetCode21. Merge Two Sorted Lists 的進階題，但本題可用 min heap 解題，還蠻巧妙的，故紀錄一下。&lt;/p>
&lt;/blockquote></description></item><item><title>JAVA Map方法： merge &amp; compute 比對</title><link>https://aryido.github.io/posts/java/java-skill-8/</link><pubDate>Sat, 01 Oct 2022 16:36:17 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-8/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java 8 因為引入了 lambda 這樣的 functional 函數，所以 Map 系列增加了一些方法，感覺還是很好用的，簡單做一些相關介紹 &amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - provider 精簡</title><link>https://aryido.github.io/posts/terraform/terragrunt-3/</link><pubDate>Thu, 29 Sep 2022 22:40:07 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-3/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Provide 是整個 terraform 最重要的元件，是決定要對哪一個平台操作 (e.g. AWS, Azure, gcp)，負責和雲端 API 的接口交互，可以在不了解 API 細節的情況下，通過 terraform 來編排資源。&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - Backend / State 設定自動化</title><link>https://aryido.github.io/posts/terraform/terragrunt-2/</link><pubDate>Tue, 27 Sep 2022 22:55:22 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-2/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terraform Backend 可將 Terraform State 存儲在雲端位置，例如 S3 bucket, azure blob storage, gcp cloud storage，並提供 lock 以防止 race conditions 。 Terragrunt 還進一步讓流程更簡便&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Terragrunt - Introduce</title><link>https://aryido.github.io/posts/terraform/terragrunt-1/</link><pubDate>Tue, 27 Sep 2022 20:45:15 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terragrunt-1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terragrunt 是 gruntwork 推出的一個 Terraform thin wrapper，在執行 Terraform 前可以先&lt;strong>調整&lt;/strong> root module 內的 .tf 檔案，保持程式碼的精簡，並提供許多額外的工具和框架幫助開發，藉此可以讓你的 IaC code 更貼近 DRY 原則。&lt;/p>
&lt;/blockquote></description></item><item><title>297. Serialize and Deserialize Binary Tree</title><link>https://aryido.github.io/posts/leetcode/leetcode297/</link><pubDate>Sun, 25 Sep 2022 14:57:06 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode297/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這題使用深度優先 Depth First Traversal 來遍歷，並使用 Pre-Order 方式記錄樹的節點值；Deserialize 時有用到 queue 來儲存節點 value 值。
之前文章也分享過，在想要 Copy Tree 時適合使用Pre-Order。這題有點符合 Copy Tree 的情境，但是是把 value 存下來。&lt;/p>
&lt;/blockquote></description></item><item><title>AWS 與 GCP reliability 不同的地方比較 - 1</title><link>https://aryido.github.io/posts/cloud/reliability1/</link><pubDate>Sat, 24 Sep 2022 19:31:37 +0800</pubDate><guid>https://aryido.github.io/posts/cloud/reliability1/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>近期有機會來比較一下 AWS 和 GCP 的一些差別，也看了一些文章(&lt;del>練英文QQ&lt;/del>)。 GCP 和 AWS 都有 auto scaling 的功能，當我們在某些時候，需要比較多的資源處理事情時，可以自動增加機器來維持高 reliability。 那這部分 GCP 和 AWS 有甚麼區別呢 ?&lt;/p>
&lt;/blockquote></description></item><item><title>JAVA Map方法：compute、computeIfAbsent、put、putIfAbsent</title><link>https://aryido.github.io/posts/java/java-skill-7/</link><pubDate>Thu, 22 Sep 2022 21:58:05 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-skill-7/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>Map 是 Java 的其中一 interface，不是 collection，也不會繼承 Collection interface。
JDK8 的 Map API 有不少便利的預設方法，以下可以介紹一下。&lt;/p></description></item><item><title>Terratag</title><link>https://aryido.github.io/posts/terraform/terratag/</link><pubDate>Wed, 21 Sep 2022 23:11:25 +0800</pubDate><guid>https://aryido.github.io/posts/terraform/terratag/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Terratag 是個 CLI 工具，可簡化 resource tag 的方式，允許將標籤應用於整個 Terraform 或 Terragrunt，對於 Terraform 社群來說，他們希望&lt;strong>集中化&lt;/strong>來標註 resource 而不是分別寫在每個resource內，以更方便的追蹤和管理&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>743. Network Delay Time</title><link>https://aryido.github.io/posts/leetcode/leetcode743/</link><pubDate>Mon, 19 Sep 2022 21:09:18 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode743/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>可以抽象成，計算從&lt;strong>初始節點&lt;/strong>到&lt;strong>最遠節點&lt;/strong>的最優路徑，很標準的 &lt;em>best first search&lt;/em>。 題目常用在水管滲透，或是網路流通，求出初始節點到每一個點到最短時間，然後取其中最大的一個就是需要的時間了。這題就是要你=實作 Dijkstra’s algorithm。&lt;/p>
&lt;/blockquote></description></item><item><title>Array &amp; ArrayList &amp; LinkedList 選擇場景</title><link>https://aryido.github.io/posts/java/array-arraylist-linkedlist/</link><pubDate>Sat, 17 Sep 2022 12:49:55 +0800</pubDate><guid>https://aryido.github.io/posts/java/array-arraylist-linkedlist/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Array 是 Java 中的基本功能，而 ArrayList 是 Collection 的一部分； ArrayList 和 LinkedList 都是 Java 中的集合類型，它們都實現了 List 接口。基本特徵簡單如下 :&lt;/p>
&lt;ul>
&lt;li>Array 是一個有固定大小的，每次創建都需要設定，而且在創建後，是不能再更改大小&lt;/li>
&lt;li>ArrayList ，是一個有浮動大小的 Array，且適用於需要快速訪問集合中的元素的場景。&lt;/li>
&lt;li>LinkedList 適用於頻繁插入和刪除元素的場景。&lt;/li>
&lt;/ul>
&lt;p>如果需要實現隊列或棧等數據結構，也可以選擇 LinkedList。&lt;/p>
&lt;/blockquote></description></item><item><title>Java 技巧 - computeIfAbsent() 用法詳解</title><link>https://aryido.github.io/posts/java/computeifabsent/</link><pubDate>Sat, 17 Sep 2022 12:44:22 +0800</pubDate><guid>https://aryido.github.io/posts/java/computeifabsent/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>使用 HashMap 的方法 :&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-jav" data-lang="jav">computeIfAbsent(K key, Function remappingFunction)
&lt;/code>&lt;/pre>&lt;p>其中 &lt;em>remappingFunction&lt;/em> 是一個 &lt;strong>Functional interface&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>input 為 map 的 &lt;strong>key&lt;/strong>&lt;/li>
&lt;li>output 會成為 map 的 &lt;strong>value&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>HashMap 的 computeIfAbsent 方法，在 key 不存在時，會做 remappingFunction 的操作，所以再也不會因為漏寫 &lt;code>if x == null&lt;/code> 而出現空指針的 bug 了。&lt;/p>
&lt;/blockquote></description></item><item><title>332. Reconstruct Itinerary</title><link>https://aryido.github.io/posts/leetcode/leetcode332/</link><pubDate>Sat, 17 Sep 2022 10:03:29 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode332/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這種飛航問題基本上都是屬於 Graph 題，題目敘述也很生活化(&lt;del>根本旅行必備知識&lt;/del>)。 因為所有的路徑有且只會被用一次，故是一個 &lt;strong>Euler Circuit&lt;/strong>。&lt;/p>
&lt;p>進一步抽象，可說這題是屬於 &lt;strong>Post-order traversal on Edges&lt;/strong> 問題。 從入口做 &lt;strong>post-order&lt;/strong> ，會是出口先被紀錄，然後再往回 &lt;strong>backtracking&lt;/strong> 回入口，把路上的所有 node 都記下來。 老實說技巧性有點太強，且還是高頻&amp;hellip;。 另外注意英文閱讀，有些單字很重要例如 &lt;em>lexical order&lt;/em>，沒注意到可能會出現錯誤。&lt;/p>
&lt;/blockquote></description></item><item><title>5. Longest Palindromic Substring</title><link>https://aryido.github.io/posts/leetcode/leetcode5/</link><pubDate>Wed, 14 Sep 2022 22:30:14 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode5/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>&lt;strong>最長回文子串 (Longest Palindromic Substring) 是常考題&lt;/strong>。Palindrome 就是正讀反讀都一樣的詞語，比如範例給的 &amp;ldquo;bab&amp;rdquo;、 &amp;ldquo;bb&amp;rdquo; ，實際單字如 &amp;ldquo;level&amp;rdquo; 等等都屬於它。因為較好的解法是 DP 類型，初見就能想到，難度也比較高。一般人能熟悉 Dynamic Programming - 2D matrix 解就好了。(看過令人膜拜的神解 Manacher&amp;rsquo;s Algorithm，時間複雜度提升到了 O(n) &amp;hellip;)&lt;/p>
&lt;/blockquote></description></item><item><title>Graph 介紹</title><link>https://aryido.github.io/posts/data-structure/graph/</link><pubDate>Tue, 13 Sep 2022 21:37:08 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/graph/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Graph 用於表示物體與物體之間存在某種關係的結構，是內存中不一定連續的資料，每個節點會一個或多個 Reference 指向其他節點&lt;/p>
&lt;ul>
&lt;li>可能有環&lt;/li>
&lt;li>分無向圖和有向圖&lt;/li>
&lt;li>沒有固定入口&lt;/li>
&lt;li>可能有多個入口&lt;/li>
&lt;/ul>
&lt;/blockquote></description></item><item><title>973. K Closest Points to Origin</title><link>https://aryido.github.io/posts/leetcode/leetcode973/</link><pubDate>Mon, 12 Sep 2022 20:12:28 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode973/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>類似這種 top k 問題且非樹結構，都可以直接用 Heap 來解題。&lt;/p>
&lt;/blockquote></description></item><item><title>230. Kth Smallest Element in a BST</title><link>https://aryido.github.io/posts/leetcode/leetcode230/</link><pubDate>Sun, 11 Sep 2022 16:12:22 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode230/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>這是一道關於二叉搜索樹 Binary Search Tree 的題目。提示是讓我們用&lt;em>中序遍歷In-Order&lt;/em>來解題。 可以複習一下 DFS 解法的 Pre-Order、In-Order Post-Order。 另外這道題的 Follow up 可以多思考，是假設該 BST 被修改的很頻繁，而且查找第 k 小元素的操作也很頻繁，問如何優化。&lt;/p>
&lt;/blockquote></description></item><item><title>Binary Search Tree</title><link>https://aryido.github.io/posts/data-structure/binary-search-tree/</link><pubDate>Sun, 11 Sep 2022 14:53:52 +0800</pubDate><guid>https://aryido.github.io/posts/data-structure/binary-search-tree/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree）。 從 wiki 上得到的時間與空間複雜度 :&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">演算法&lt;/th>
&lt;th style="text-align:center">平均&lt;/th>
&lt;th style="text-align:center">最差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">空間&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">搜尋&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">插入&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">刪除&lt;/td>
&lt;td style="text-align:center">O(log n)&lt;/td>
&lt;td style="text-align:center">O(n)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/blockquote></description></item><item><title>Java 技巧 - Java Arrays 方法</title><link>https://aryido.github.io/posts/java/java-arrays/</link><pubDate>Fri, 09 Sep 2022 19:59:56 +0800</pubDate><guid>https://aryido.github.io/posts/java/java-arrays/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>刷題時很常出現 Array 的結構如 &lt;code>int[]、char[]&lt;/code> 等等&amp;hellip;，故在這邊條列一些常用的 Arrays 方法。這次主要整理下 Java 中 Arrays 類的常用方法，在使用過程也可以複習 java 提供的工具類，還有一些泛型的坑&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>Grafana: panel之間共享查詢結果以減少loading時間</title><link>https://aryido.github.io/posts/monitoring/panel-loading-enhancement/</link><pubDate>Thu, 08 Sep 2022 22:18:02 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/panel-loading-enhancement/</guid><description>&lt;blockquote>
&lt;p>Grafana 的 panel 會連接 datasource 並發出請求。 故當我們向 dashboard 中添加多個 panel 時，會發出更多的請求，這可能會導致需要更長的時間來loading資料。&lt;/p>
&lt;/blockquote></description></item><item><title>200. Number of Islands</title><link>https://aryido.github.io/posts/leetcode/leetcode200/</link><pubDate>Wed, 07 Sep 2022 20:55:05 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode200/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>剛開始刷題時就覺得這題很有趣，有 game 的感覺。可以用來複習DFS、BFS。&lt;/p></description></item><item><title>Java 技巧 - 處理Map&lt;K, Collection&lt;T>></title><link>https://aryido.github.io/posts/java/map-of-collection/</link><pubDate>Tue, 06 Sep 2022 23:28:59 +0800</pubDate><guid>https://aryido.github.io/posts/java/map-of-collection/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>經常有一些業務邏輯要用 Map 來解決，如果再多懂得一些 Map 的方法，是可以寫出精簡的 code 的。這裡展示一些優雅處理 &lt;code>Map&amp;lt;K, Collection&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 類型的方式。&lt;/p>
&lt;/blockquote></description></item><item><title>735. Asteroid Collision</title><link>https://aryido.github.io/posts/leetcode/leetcode735/</link><pubDate>Mon, 05 Sep 2022 20:42:24 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode735/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p>
&lt;p>這題雖然好玩但我寫起來真的BUG滿天飛，小行星碰撞 Asteroid Collision。&lt;/p></description></item><item><title>739. Daily Temperatures by Java</title><link>https://aryido.github.io/posts/leetcode/leetcode739/</link><pubDate>Mon, 05 Sep 2022 10:59:38 +0800</pubDate><guid>https://aryido.github.io/posts/leetcode/leetcode739/</guid><description>&lt;!-- raw HTML omitted -->
&lt;p>不定時練習LeetCode紀錄&amp;hellip;&lt;/p></description></item><item><title>Stack、Deque、ArrayDeque、LinkedList 介紹</title><link>https://aryido.github.io/posts/java/stack-deque-arraydeque-linkedlist/</link><pubDate>Mon, 05 Sep 2022 00:54:48 +0800</pubDate><guid>https://aryido.github.io/posts/java/stack-deque-arraydeque-linkedlist/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>Java 現在 Stack 類已經&lt;strong>不建議&lt;/strong>使用。現在推薦的是，使用雙端隊列接口 Deque 取代 Stack。 Deque 是 interface，有兩個常用的 implement :&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ArrayDeque&lt;/strong>&lt;/li>
&lt;li>&lt;strong>LinkedList&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>簡單來介紹和比較一下。&lt;/p>
&lt;/blockquote></description></item><item><title>建立自己的 grafana dashboard plugin - 2</title><link>https://aryido.github.io/posts/monitoring/grafana-dashboard-plugin-2/</link><pubDate>Sun, 04 Sep 2022 11:17:52 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/grafana-dashboard-plugin-2/</guid><description>&lt;blockquote>
&lt;p>參考&lt;a href="https://grafana.com/tutorials/build-a-panel-plugin/">官方教學&lt;/a>遇到的一些小問題&amp;hellip;&lt;/p>
&lt;/blockquote></description></item><item><title>建立自己的 grafana dashboard plugin - 1</title><link>https://aryido.github.io/posts/monitoring/grafana-dashboard-plugin-1/</link><pubDate>Sun, 04 Sep 2022 11:17:02 +0800</pubDate><guid>https://aryido.github.io/posts/monitoring/grafana-dashboard-plugin-1/</guid><description>&lt;blockquote>
&lt;p>雖然 Grafana 已經內置了多種類型的dashboard，但有時候可能會覺得官方或其他免費開源plugin，提供的功能不太夠。這時就需要建立自己的dashboard。&lt;/p>
&lt;/blockquote></description></item><item><title>Java 泛型注意事項 - List of array 轉成 2D-array</title><link>https://aryido.github.io/posts/java/2d-array/</link><pubDate>Thu, 01 Sep 2022 08:11:32 +0800</pubDate><guid>https://aryido.github.io/posts/java/2d-array/</guid><description>&lt;!-- raw HTML omitted -->
&lt;blockquote>
&lt;p>把 List of array 轉成 2D-array&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 記得 list.size()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 後面還有個[]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>T result&lt;span style="color:#f92672">[][]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toArray&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> T&lt;span style="color:#f92672">[&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()][]);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 實際 example
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> listOfIntegers &lt;span style="color:#f92672">=&lt;/span> List&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">of&lt;/span>&lt;span style="color:#f92672">(&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">},&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">55&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#ae81ff">65&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> array2D &lt;span style="color:#f92672">=&lt;/span> listOfIntegers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toArray&lt;/span>&lt;span style="color:#f92672">(&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>listOfIntegers&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()][]&lt;/span> &lt;span style="color:#f92672">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote></description></item></channel></rss>